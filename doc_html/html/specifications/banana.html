

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>The Banana Protocol &mdash; Foolscap v0.6.1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.6.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Foolscap v0.6.1 documentation" href="../index.html" />
    <link rel="next" title="Foolscap Logging Formats" href="logfiles.html" />
    <link rel="prev" title="Using Foolscap for Serialization" href="../serializing.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="logfiles.html" title="Foolscap Logging Formats"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../serializing.html" title="Using Foolscap for Serialization"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Foolscap v0.6.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="the-banana-protocol">
<h1>The Banana Protocol<a class="headerlink" href="#the-banana-protocol" title="Permalink to this headline">¶</a></h1>
<p><em>NOTE! This is all preliminary and is more an exercise in semiconscious protocol design than anything else. Do not believe this document. This sentence is lying. So there.</em></p>
<div class="section" id="banana-tokens">
<h2>Banana tokens<a class="headerlink" href="#banana-tokens" title="Permalink to this headline">¶</a></h2>
<p>At the lowest layer, the wire transport takes the form of Tokens. These
all take the shape of header/type-byte/body.</p>
<ul class="simple">
<li>Header: zero or more bytes, all of which have the high bit clear (they
range in value from 0 to 127). They form a little-endian base-128 number,
so 1 is represented as 0x01, 128 is represented as 0x00 0x01, 130 as 0x02
0x01, etc. 0 can be represented by any string of 0x00 bytes, including an
empty string. The maximum legal header length is 64 bytes, so it has a
maximum value of 2**(64*7)-1. Not all tokens have headers.</li>
<li>Type Byte: the high bit is set to distinguish it from the header bytes
that precede it (it has a value from 128 to 255). The Type Byte determines
how to interpret both the header and the body. All valid type bytes are
listed below.</li>
<li>Body: zero or more arbitrary bytes, length is specified by the
header. Not all tokens have bodies.</li>
</ul>
<p>Tokens are described below as [header-TOKEN-body], where either&#8221;header&#8221; or &#8220;body&#8221; may be empty. For example, [len-LIST-empty]
indicates that the length is put into the header, &#8220;LIST&#8221; is the token
being used, and the body is empty.</p>
<p>The possible Token types are:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">0x80:</span> <span class="pre">LIST</span> <span class="pre">(old):</span> <span class="pre">[len-LIST-empty]</span></tt></p>
<p>This token marks the beginning of a list with LEN elements. It acts as
the &#8220;open parenthesis&#8221; , and the matching &#8220;close parenthesis&#8221; is
implicit, based upon the length of the list. It will be followed by LEN
things, which may be tokens like INTs or STRINGS, or which may be
sublists. Banana keeps a list stack to handle nested sublists.</p>
<p>This token (and the notion of length-prefixed lists in general) is from
oldbanana. In newbanana it is only used during the initial dialect
negotiation (so that oldbanana peers can be detected). Newbanana requires
that LIST(old) tokens be followed exclusively by strings and have a rather
limited allowable length (say, 640 dialects long).</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">0x81:</span> <span class="pre">INT:</span> <span class="pre">[value-INT-empty]</span></tt></p>
<p>This token defines a single positive integer. The protocol defines its
range as [0, 2**31), so the largest legal value is 2**31-1. The
recipient is responsible for choosing an appropriate local type to hold the
number. For Python, if the value represented by the incoming base-128
digits grows larger than a regular Python IntType can accomodate, the
receiving system will use a LongType or a BigNum as necessary.</p>
<p>Anything larger than this range must be sent with a LONGINT token
instead.</p>
<p>(oldbanana compatibility note: a python implementation can accept
anything in the range [0, 2**448), limited by the 64-byte maximum header
size).</p>
<p>The range was chosen to allow INT values to always fit in C&#8217;s s_int32_t
type, so an implementation that doesn&#8217;t have a useful bignum type can
simply reject LONGINT tokens.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">0x82:</span> <span class="pre">STRING</span> <span class="pre">[len-STRING-chars]</span></tt></p>
<p>This token defines a string. To be precise, it defines a sequence of
bytes. The length is a base-128-encoded integer. The type byte is followed
by LEN bytes of data which make up the string. LEN is required to be
shorter than 640k: this is intended to reduce the amount of memory that
can be consumed on the receiving end before user code gets to decide
whether to accept the data or not.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">0x83:</span> <span class="pre">NEG:</span> <span class="pre">[value-NEG-empty]</span></tt></p>
<p>This token defines a negative integer. It is identical to the
<tt class="docutils literal"><span class="pre">INT</span></tt> tag except that the results are negated before storage.
The range is defined as [-2**31, 0), again to make an implementation using
s_int32_t easier. Any numbers smaller (more negative) than this range must
be sent with a LONGNEG token.</p>
<p>Implementations should be tolerant when receiving a &#8220;negative zero&#8221;
and turn it into a 0, even though they should not send such things.</p>
<p>Note that NEG can represent a number (-2**31) whose absolute value
(2**31) is one larger than the greatest number that INT can represent
(2**31-1).</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">0x84:</span> <span class="pre">FLOAT</span> <span class="pre">[empty-FLOAT-value]</span></tt></p>
<p>This token defines a floating-point number. There is no header, and the
type byte is followed by 8 bytes which are a 64-bit IEEE &#8220;double&#8221; , as
defined by <tt class="docutils literal"><span class="pre">struct.pack(&quot;!d&quot;,</span> <span class="pre">num)</span></tt> .</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">0x85:</span> <span class="pre">OLDLONGINT:</span> <span class="pre">[value-OLDLONGINT-empty]</span></tt></p>
<p><tt class="docutils literal"><span class="pre">0x86:</span> <span class="pre">OLDLONGNEG:</span> <span class="pre">[value-OLDLONGNEG-empty]</span></tt></p>
<p>These were used by oldbanana to represent large numbers. Their size was
limited by the number of bytes in the header (max 64), so they can
represent [0, 2**448).</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">0x87:</span> <span class="pre">VOCAB:</span> <span class="pre">[index-VOCAB-empty]</span></tt></p>
<p>This defines a tokenized string. Banana keeps a mapping of common
strings, each one is assigned a small integer. These strings can be sent
compressed as a two-byte (index, VOCAB) sequence. They are delivered to
Jelly as plain strings with no indication that they were compressed for
transit.</p>
<p>The strings in this mapping are populated by the sender when it sends a
special &#8220;vocab&#8221; OPEN sequence. The intention is that this mapping
will be sent just once when the connection is first established, but a
sufficiently ambituous sender could use this to implement adaptive forward
compression.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">0x88:</span> <span class="pre">OPEN:</span> <span class="pre">[[num]-OPEN-empty]</span></tt></p>
<p><tt class="docutils literal"><span class="pre">0x89:</span> <span class="pre">CLOSE:</span> <span class="pre">[[num]-CLOSE-empty]</span></tt></p>
<p>These tokens are the newbanana parenthesis markers. They carry an
optional number in their header: if present, the number counts the
appearance of OPEN tokens in the stream, starting at 0 for the first OPEN
used for a given connection and incrementing by 1 for each subsequent
OPEN. The matching CLOSE token must contain an identical number. These
numbers are solely for debugging and may be omitted. They may be removed
from the protocol once development has been completed.</p>
<p>In contrast to oldbanana (with the LIST token), newbanana does not use
length-prefixed lists. Instead it relies upon the Banana layer to track
OPEN/CLOSE tokens.</p>
<p>OPEN markers are followed by the &#8220;Open Index&#8221; tuple: one or more
tokens to indicate what kind of new sub-expression is being started. The
first token must be a string (either STRING or VOCAB), the rest may be
strings or other primitive tokens. The recipient decides when the Open
Index has finished and the body has begun.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">0x8A:</span> <span class="pre">ABORT:</span> <span class="pre">[[num]-ABORT-empty]</span></tt></p>
<p>This token indicates that something has gone wrong on the sender side,
and that the resulting object must not be handed upwards in the unslicer
stack. It may be impossible or inconvenient for the sender to stop sending
the tokens associated with the unfortunate object, so the receiver must be
prepared to silently drop all further tokens up to the matching STOP
marker. The STOP token must always follow eventually: this is just a
courtesy notice.</p>
<p>The number, if present, will be the same one used by the OPEN
token.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">0x8B:</span> <span class="pre">LONGINT:</span> <span class="pre">[len-LONGINT-bytes]</span></tt></p>
<p><tt class="docutils literal"><span class="pre">0x8C:</span> <span class="pre">LONGNEG:</span> <span class="pre">[len-LONGNEG-bytes]</span></tt></p>
<p>These are processed like STRING tokens, but the bytes form a base-256
encoded number, most-significant-byte first (note that this may require
several passes and some intermediate storage). The size is (barely) limited
by the length field, so the theoretical range is [0, 2**(2**(64*7)-1)-1),
but the receiver can impose whatever length limit they wish.</p>
<p>LONGNEG is handled exactly like LONGINT but the number is negated
first.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">0x8D:</span> <span class="pre">ERROR</span> <span class="pre">[len-ERROR-chars]</span></tt></p>
<p>This token defines a string of ASCII characters which hold an error
message. When a severe protocol violation occurs, the offended side will
emit an ERROR token and then close the transport. The side which receives
the ERROR token should put the message in a developer-readable logfile and
close the transport as well.</p>
<p>The ERROR token is formatted exactly like the STRING token, except that
it is defined to be encoded in ASCII (the STRING token does not claim to
be encoded in any particular character set, nor does it necessarily
represent human-readable characters).</p>
<p>The ERROR token is limited to 1000 characters.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">0x8E:</span> <span class="pre">PING</span> <span class="pre">[[num]-PING-empty]</span></tt></p>
<p><tt class="docutils literal"><span class="pre">0x8F:</span> <span class="pre">PONG</span> <span class="pre">[[num]-PONG-empty]</span></tt></p>
<p>These tokens have no semantic value, but are used to implement
connection timeouts and keepalives. When one side receives a PING message,
it should immediately queue a PONG message on the return stream. The
optional number can be used to associate a PONG with the PING that prompted
it: if present, it must be duplicated in the response.</p>
<p>Other than generating a PONG, these tokens are ignored by both ends.
They are not delivered to higher levels. They may appear in the middle of
an OPEN sequence without affecting it.</p>
<p>The intended use is that each side is configured with two timers: the
idle timer and the disconnect timer. The idle timer specifies how long the
inbound connection is allowed to remain quiet before poking it. If no data
has been received for this long, a PING is sent to provoke some kind of
traffic. The disconnect timer specifies how long the inbound connection is
allowed to remain quiet before concluding that the other end is dead and
thus terminating the connection.</p>
</li>
</ul>
<p>These messages can also be used to estimate the connection&#8217;s round-trip
time (including the depth of the transmit/receive queues at either end).
Just send a PING with a unique number, and measure the time until the
corresponding PONG is seen.</p>
<p>TODO: Add TRUE, FALSE, and NONE tokens. (maybe? These are currently
handled as OPEN sequences)</p>
</div>
<div class="section" id="serialization">
<h2>Serialization<a class="headerlink" href="#serialization" title="Permalink to this headline">¶</a></h2>
<p>When serializing an object, it is useful to view it as a directed graph.
The root object is the one you start with, any objects it refers to are
children of that root. Those children may point back to other objects that
have already been serialized, or which will be serialized later.</p>
<p>Banana, like pickle and other serialization schemes, does a depth-first
traversal of this graph. Serialization is begun on each node before going
down into the child nodes. Banana tracks previously-handled nodes and
replaces them with numbered <tt class="docutils literal"><span class="pre">reference</span></tt> tokens to break loops in
the graph.</p>
<div class="section" id="banana-slicers">
<h3>Banana Slicers<a class="headerlink" href="#banana-slicers" title="Permalink to this headline">¶</a></h3>
<p>A <em>Banana Slicer</em> is responsible for serializing a single user
object: it &#8220;slices&#8221; that object into a series of smaller pieces, either
fundamental Banana tokens or other Sliceable objects. On the receiving end,
there is a corresponding <em>Banana Unslicer</em> which accepts the incoming
tokens and re-creates the user object. There are different kinds of Slicers
and Unslicers for lists, tuples, dictionaries, etc. Classes can provide
their own Slicers if they want more control over the serialization
process.</p>
<p>In general, there is a Slicer object for each act of serialization of a
given object (although this is not strictly necessary). This allows the
Slicer to contain state about the serialization process, which enables
producer/consumer -style pauses, and slicer-controlled streaming
serialization. The entire context is stored in a small tuple (which includes
the Slicer), so it can be set aside for a while. In the future, this will
allow interleaved serialization of multiple objects (doing context switching
on the wire), to do things like priority queues and avoid head-of-line
blocking.</p>
<p>The most common pattern is to have the Slicer be the <tt class="docutils literal"><span class="pre">ISlicer</span></tt>
Adapter for the object, in which it gets a new Slicer case each it is
serialized. Classes which do not need to store a lot of state can have a
single Slicer per serialized object, presumably through some adapter tricks.
It is also valid to have the serialized object be its own Slicer.</p>
<p>The Slicer has other duties (described below), but the main one is to
implement the <tt class="docutils literal"><span class="pre">slice</span></tt> method, which should return a sequence or
an iterable which yields the Open Index Tokens, followed by the body tokens.
(Note that the Slicer should not include the OPEN or CLOSE tokens: those are
supplied by the SendBanana wrapping code). Any item which is a fundamental
type (int, string, float) will be sent as a banana token, anything else will
be handled by recursion (with a new Slicer).</p>
<p>Most subclasses of <tt class="docutils literal"><span class="pre">BaseSlicer</span></tt> implement a companion method
named <tt class="docutils literal"><span class="pre">sliceBody</span></tt> , which supplies just the body tokens. (This
makes the code a bit easier to follow). <tt class="docutils literal"><span class="pre">sliceBody</span></tt> is usually
just a &#8220;return [token, token]&#8221; , or a series of <tt class="docutils literal"><span class="pre">yield</span></tt>
statements, one per token. However, classes which wish to have more control
over the process can implement <tt class="docutils literal"><span class="pre">sliceBody</span></tt> or even``slice`` differently.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ThingySlicer</span><span class="p">(</span><span class="n">slicer</span><span class="o">.</span><span class="n">BaseSlicer</span><span class="p">):</span>
    <span class="n">opentype</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;thingy&#39;</span><span class="p">,)</span>
    <span class="n">trackReferences</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">sliceBody</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">streamable</span><span class="p">,</span> <span class="n">banana</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">attr1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">attr2</span><span class="p">]</span>
</pre></div>
</div>
<p>If &#8220;attr1&#8221; and &#8220;attr2&#8221; are integers, the preceding Slicer would
create a token sequence like: OPEN STRING(thingy) 13 16 CLOSE. If&#8221;attr2&#8221; were actually another Thingy instance, it might produce OPEN
STRING(thingy) 13 OPEN STRING(thingy) 19 18 CLOSE CLOSE.</p>
<p>Doing this with a generator gives the same basic results but avoids the
temporary buffer, which can be important when sending large amounts of data.
The following Slicer could be combined with a concatenating Unslicer to
implement the old FilePager class without the extra round-trip
inefficiencies.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">DemandSlicer</span><span class="p">(</span><span class="n">slicer</span><span class="o">.</span><span class="n">BaseSlicer</span><span class="p">):</span>
    <span class="n">opentype</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;demandy&#39;</span><span class="p">,)</span>
    <span class="n">trackReferences</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">sliceBody</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">streamable</span><span class="p">,</span> <span class="n">banana</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;data&quot;</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2048</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">chunk</span>
</pre></div>
</div>
<p>The SendBanana code controls the pacing: if the transport is full, it has
the option of pausing the generator until the receiving end has caught up.
It also has the option of pulling tokens out of the Slicer anyway, and
buffering them in memory. This may be necessary to achieve serialization
coherency, discussed below.</p>
<p>If the &#8220;streamable&#8221; flag is set, then the <em>slicer</em> gets to
control the pacing too: it is allowed to yield a Deferred where it would
normally provide a regular token. This tells Banana that serialization needs
to wait for a while (perhaps we are streaming data from another source which
has run dry, or we are trying to implement some kind of rate limiting).
Banana will wait until the Deferred fires before attempting to retrieve
another token. If the &#8220;streamable&#8221; flag is <em>not</em> set, then a
parent Slicer has decided that it is unwilling to allow streaming (perhaps
it needs to serialize a coherent state, and a pause for streaming would
allow that state to change before it was completely serialized). The Slicer
is not allowed to return a Deferred when streaming is disabled.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">URLGetterSlicer</span><span class="p">(</span><span class="n">slicer</span><span class="o">.</span><span class="n">BaseSlicer</span><span class="p">):</span>
    <span class="n">opentype</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;urldata&#39;</span><span class="p">,)</span>
    <span class="n">trackReferences</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">gotPage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">page</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span>

    <span class="k">def</span> <span class="nf">sliceBody</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">streamable</span><span class="p">,</span> <span class="n">banana</span><span class="p">):</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">url</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">web</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">getPage</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">addCallback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gotPage</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">d</span>
        <span class="c"># here we hover in limbo until it fires</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">page</span>
</pre></div>
</div>
<p>(the code is a bit kludgy because generators have no way to pass data
back out of the &#8220;yield&#8221; statement).</p>
<p>The Slicer can also raise a &#8220;Violation&#8221; exception, in which case the
slicer will be aborted: no further tokens will be pulled from it. This
causes an ABORT token to be sent over the wire, followed immediately by a
CLOSE token. The dead Slicer&#8217;s parent is notified with a``childAborted`` method, then the Banana continues to extract
tokens from the parent as if the child had finished normally. (TODO: we need
a convenient way for the parent to indicate that it wishes to give up too,
such as raising a Violation from within <tt class="docutils literal"><span class="pre">childAborted</span></tt> ).</p>
</div>
<div class="section" id="serialization-coherency">
<h3>Serialization Coherency<a class="headerlink" href="#serialization-coherency" title="Permalink to this headline">¶</a></h3>
<p>Streaming serialization means the object is serialized a little bit at a
time, never consuming too much memory at once. The tradeoff is that, by
doing other useful work inbetween, our object may change state while it is
being serialized. In oldbanana this process was uninterruptible, so
coherency was not an issue. In newbanana it is optional. Some objects may
have more trouble with this than others, so Banana provides Slicers with a
means to influence the process.</p>
<p>Banana makes certain promises about what takes place between successive&#8221;yield&#8221; statements, when the Slicer gives up control to Banana. The
most conservative approach is to:</p>
<ul class="simple">
<li>disable the RootSlicer&#8217;s &#8220;streamable&#8221; flag to tell all Slicers
that they should not return Deferreds: this avoids loss of control due
to child Slicers giving it away</li>
<li>set the SendBanana policy to buffer data in memory rather than do a
.pauseProducing: this removes pauses due to the output channel filling
up</li>
<li>return a list from <tt class="docutils literal"><span class="pre">slice</span></tt> (or <tt class="docutils literal"><span class="pre">sliceBody</span></tt> )
instead of using a generator: this fixes the object contents at a single
point in time. (you can also create a list at the beginning of that
routine and then yield pieces of it, which has exactly the same
effect)</li>
</ul>
<p>Slicers aren&#8217;t supposed to do anything which changes the state observed
by other Slicers: if this is really the case than it is safe to use a
generator. A parent Slicer which yields a non-primitive object will give up
control to the child Slicer needed to handle that object, but that child
should do its business and finish quickly, so there should be no way for the
parent object&#8217;s state to change in the meantime.</p>
<p>If the SendBanana is allowed to give up control (.pauseProducing), then
arbitrary code will get to run in between &#8220;yield&#8221; calls, possibly
changing the state being accessed by those yields. Likewise child Slicers
might give up control, threatening the coherency of one of their parents.
Slicers can invoke <tt class="docutils literal"><span class="pre">banana.inhibitStreaming()</span></tt> (TODO: need a
better name) to inhibit streaming, which will cause all child serialization
to occur immediately, buffering as much data in memory as necessary to
complete the operation without give up control.</p>
<p>Coherency issues are a new area for Banana, so expect new tools and
techniques to be developed which allow the programmer to make sensible
tradeoffs.</p>
</div>
<div class="section" id="the-slicer-stack">
<h3>The Slicer Stack<a class="headerlink" href="#the-slicer-stack" title="Permalink to this headline">¶</a></h3>
<p>The serialization context is stored in a &#8220;SendBanana&#8221; object, which
is one of the two halves of the Banana object (a subclass of Protocol). This
holds a stack of Banana Slicers, one per object currently being serialized
(i.e. one per node in the path from the root object to the object currently
being serialized).</p>
<p>For example, suppose a class instance is being serialized, and this class
chose to use a dictionary to hold its instance state. That dictionary holds
a list of numbers in one of its values. While the list of numbers is being
serialized, the Slicer Stack would hold: the RootSlicer, an InstanceSlicer,
a DictSlicer, and finally a ListSlicer.</p>
<p>The stack is used to determine two things:</p>
<ul class="simple">
<li>How to handle a child object: which Slicer should be used, or if a
Violation should be raised</li>
<li>How to track object references, to break cycles in the object graph</li>
</ul>
<p>When a new object needs to be sent, it is first submitted to the top-most
Slicer (to its <tt class="docutils literal"><span class="pre">slicerForObject</span></tt> method), which is responsible
for either returning a suitable Slicer or raising a Violation exception (if
the object is rejected by a security policy). Most Slicers will just
delegate this method up to the RootSlicer, but Slicers which wish to pass
judgement upon enclosed objects (or modify the Slicer selected) can do
something else. Unserializable objects will raise an exception here.</p>
<p>Once the new Slicer is obtained, the OPEN token is emitted, which
provides the &#8220;openID&#8221; number (just an implicit count of how many OPEN
tokens have been sent over the wire). This is where we break cycles in the
object graph: before serializing the object, we record a reference to it
(the openID), and any time we encounter the object again, we send the
reference number instead of a new copy. This reference number is tracked in
the SlicerStack, by handing the number/object pair to the top-most Slicer&#8217;s``registerReference`` method. Most Slicers will delegate this up to
the RootSlicer, but again they can perform additional registrations or
consume the request entirely. This is used in PB to provide &#8220;scoped references&#8221; , where (for example) a list <em>should</em> be sent twice if
it occurs in two separate method calls. In this case the CallSlicer (which
sits above the PBRootSlicer) does its own registration.</p>
<p>The <tt class="docutils literal"><span class="pre">slicerForObject</span></tt> process is responsible for catching the
second time the object is sent. It looks in the same mapping created by``registerReference`` and returns a <tt class="docutils literal"><span class="pre">ReferenceSlicer</span></tt>
instead of the usual one.</p>
<p>The <tt class="docutils literal"><span class="pre">RootSlicer</span></tt> , which sits at the bottom of the stack, is a
special case. It is never pushed or popped, and implements most of the
policy for the whole Banana process. The RootSlicer can also be interpreted
as a &#8220;root object&#8221; , if you imagine that any given user object being
serialized is somehow a child of the overall serialization context. In PB,
for example, the root object would be related to the connection and needs to
track things like which remotely-invokable objects are available.</p>
<p>The default RootSlicer implements the following behavior:</p>
<ul class="simple">
<li>Allow all objects to be serialized that can be</li>
<li>Use its <tt class="docutils literal"><span class="pre">.slicerTable</span></tt> to get a Slicer for an object. If
that fails, adapt the object to ISlicer</li>
<li>Record object references in its <tt class="docutils literal"><span class="pre">.references</span></tt> dict</li>
</ul>
<p>The <tt class="docutils literal"><span class="pre">RootSlicer</span></tt> class only does &#8220;safe&#8221; serialization:
basic types and whatever you&#8217;ve registered an ISlicer adapter for. The``TrustingRootSlicer`` uses that .slicerTable mapping to serialize
unsafe things (arbitrary instances, classes, etc), which is suitable for
local storage instead of network communication (i.e. when you want to use
banana as a pickle replacement).</p>
<p>TODO: The idea is to let other serialization contexts do other things.
For example, the final tokens could go to the parent slice for handling
instead of straight to the Protocol, which would provide more control over
turning the tokens into bytes and sending over a wire, saving to a file,
etc.</p>
<p>Finally, the stack can be queried to find out what path leads from the
root object to the one currently being serialized. If something goes wrong
in the serialization process (an exception is thrown), this path can make it
much easier to find out <em>when</em> the trouble happened, as opposed to
merely where. Knowing that the &#8221;.oops&#8221; method of your FooObject failed
during serialization isn&#8217;t very useful when you have 500 FooObjects inside
your data structure and you need to know whether it was``bar.thisfoo`` or <tt class="docutils literal"><span class="pre">bar.thatfoo</span></tt> which caused the
problem. To this end, each Slicer has a <tt class="docutils literal"><span class="pre">.describe</span></tt> method which
is supposed to return a short string that explains how to get to the child
node currently being processed. When an error occurs, these strings are
concatenated together and put into the failure object.</p>
</div>
</div>
<div class="section" id="deserialization">
<h2>Deserialization<a class="headerlink" href="#deserialization" title="Permalink to this headline">¶</a></h2>
<p>The other half of the Banana class is the <tt class="docutils literal"><span class="pre">ReceiveBanana</span></tt> ,
which accepts incoming tokens and turns them into objects. It is organized
just like the <tt class="docutils literal"><span class="pre">SendBanana</span></tt> , with a stack of &#8220;Banana Unslicer&#8221; objects, each of which assembles tokens or child objects into a
larger one. Each Unslicer receives the tokens emitted by the matching Slicer
on the sending side. The whole stack is used to create new Unslicers,
enforce restrictions upon what objects will be accepted, and manage object
references.</p>
<p>Each Unslicer accepts tokens that turn into an object of some sort. They
pass this object up to their parent Unslicer. Eventually a finished object
is given to the <tt class="docutils literal"><span class="pre">RootUnslicer</span></tt> , which decides what to do with it.
When the Banana is being used for data storage (like pickle), the root will
just deliver the object to the caller. When Banana is used in PB, the actual
work is done by some intermediate objects like the``CallUnslicer`` , which is responsible for a single method
invocation.</p>
<p>The <tt class="docutils literal"><span class="pre">ReceiveBanana</span></tt> itself is responsible for pulling
well-formed tokens off the incoming data stream, tracking OPEN and CLOSE
tokens, maintaining synchronization with the transmitted token stream, and
discarding tokens when the receiving Unslicers have rejected one of the
inbound objects. Unslicer methods may raise Violation exceptions: these are
caught by the Unbanana and cause the object currently being unserialized to
fail: its parent gets a UnbananaFailure instead of the dict or list or
instance that it would normally have received.</p>
<p>OPEN tokens are followed by a short list of tokens called the&#8221;opentype&#8221; to indicate what kind of object is being started. This is
looked up in the UnbananaRegistry just like object types are looked up in
the BananaRegistry (TODO: need sensible adapter-based registration scheme
for unslicing). The new Unslicer is pushed onto the stack.</p>
<p>&#8220;ABORT&#8221; tokens indicate that something went wrong on the sending
side and that the current object is to be aborted. It causes the receiver to
discard all tokens until the CLOSE token which closes the current node. This
is implemented with a simple counter of how many levels of discarding we
have left to do.</p>
<p>&#8220;CLOSE&#8221; tokens finish the current node. The Unslicer will pass its
completed object up to the &#8220;receiveChild&#8221; method of its parent.</p>
<div class="section" id="open-index-tokens-the-opentype">
<h3>Open Index tokens: the Opentype<a class="headerlink" href="#open-index-tokens-the-opentype" title="Permalink to this headline">¶</a></h3>
<p>OPEN tokens are followed by an arbitrary list of other tokens which are
used to determine which UnslicerFactory should be invoked to create the new
Unslicer. Basic Python types are designated with a simple string, like (OPEN&#8221;list&#8221; ) or (OPEN &#8220;dict&#8221; ), but instances are serialized with two
strings (OPEN &#8220;instance&#8221; &#8220;classname&#8221; ), and various exotic PB
objects like method calls may involve a list of strings and numbers (OPEN&#8221;call&#8221; reqID objID methodname). The unbanana code works with the
unslicer stack to apply constraints to these indexing tokens and finally
obtain the new Unslicer when enough indexing tokens have been received.</p>
<p>The reason for assembling this &#8220;opentype&#8221; list before creating the
Unslicer (instead of using a generic InstanceUnslicer which switches
behavior depending upon its first received token) is to support classes or
PB methods which wish to push custom Unslicers to handle their
deserialization process. For example, a class could push a
StreamingFileUnslicer that accepts a series of string tokens and appends
their contents to a file on disk. This Unslicer could reduce memory
consumption (by only holding one chunk at a time) and update some kind of
progress indicator as the data arrives. This particular feature was provided
by the old StringPager utility, but custom Unslicers offer more flexibility
and better efficiency (no additional round-trips).</p>
<p>(note: none of this affects the serialization side: those Slicers emit
both their indexing tokens and their state tokens. It is only the receiving
side where the index tokens are handled by a different piece of code than
the content tokens).</p>
<p>In yet greater detail:</p>
<ul class="simple">
<li>Each OPEN sequence is divided into an &#8220;Index phase&#8221; and a
&#8220;Contents phase&#8221; . The first one (or two or three) tokens are the
Index Tokens and the rest are the Body Tokens. The sequence ends with a
CLOSE token.</li>
<li>Banana.inOpen is a boolean which indicates that we are in the Index
Phase. It is set to True when the OPEN token is received and returns to
False after the new Unslicer has been pushed.</li>
<li>Banana.opentype is a list of Index Tokens that are being accumulated.
It is cleared each time .inOpen is set to True. The tuple form of opentype
is passed to Slicer.doOpen, Constraint.checkOpentype, and used as a key in
the RootSlicer.openRegistry dictionary. Each Unslicer type is indexed by
an opentype tuple.</li>
</ul>
<p>If .inOpen is True, each new token type will be passed (through
Banana.getLimit and top.openerCheckToken) to the opener&#8217;s .openerCheckToken
method, along with the current opentype tuple. The opener gets to decide if
the token is acceptable (possibly raising a Violation exception). Note that
the opener does not maintain state about what phase the decoding process is
in, so it may want to condition its response upon the length of the
opentype.</p>
<p>After each index token is complete, it is appended to .opentype, then the
list is passed (through Banana.handleOpen, top.doOpen, and top.open) to the
opener&#8217;s .open method. This can either return an Unslicer (which will finish
the index phase: all further tokens will be sent to the new Unslicer),
return None (to continue the index phase), raise a Violation (which causes
an UnbananaFailure to be passed to the current top unslicer), or raise
another exception (which causes the connection to be abandoned).</p>
</div>
<div class="section" id="unslicer-lifecycle">
<h3>Unslicer Lifecycle<a class="headerlink" href="#unslicer-lifecycle" title="Permalink to this headline">¶</a></h3>
<p>Each Unslicer has access to the following attributes:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">.parent</span></tt> : This is set by the ReceiveBanana before
<tt class="docutils literal"><span class="pre">.start</span></tt> is invoked, and provides a reference to the Unslicer
responsible for the containing object. You can follow <tt class="docutils literal"><span class="pre">.parent</span></tt>
all the way up the object graph to the single <tt class="docutils literal"><span class="pre">RootUnslicer</span></tt>
object for this connection. It is appropriate to invoke
<tt class="docutils literal"><span class="pre">openerCheckToken</span></tt> and <tt class="docutils literal"><span class="pre">open</span></tt> on your parent.</li>
<li><tt class="docutils literal"><span class="pre">.protocol</span></tt> : This is set by the ReceiveBanana before
<tt class="docutils literal"><span class="pre">.start</span></tt> is invoked, and provides access to the Banana object
which maintains the connection on which this object is being received. It
is appropriate to examine the <tt class="docutils literal"><span class="pre">.debugReceive</span></tt> attribute on the
protocol. It is also appropriate to invoke <tt class="docutils literal"><span class="pre">.setObject</span></tt> on it
to register references for shared containers (like lists).</li>
<li><tt class="docutils literal"><span class="pre">openCount</span></tt> : This is set by the ReceiveBanana before
<tt class="docutils literal"><span class="pre">.start</span></tt> is invoked, and contains the optional OPEN-count for
this object, an implicit sequence number incremented for each OPEN token
seen on the wire. During protocol development and testing the OPEN tokens
may include an explicit OPEN-count value, but usually it is left out of
the packet. If present, it is used by Banana.handleClose to assert that
the CLOSE token is associated with the right OPEN token. Unslicers will
not normally have a use for it.</li>
<li><tt class="docutils literal"><span class="pre">.count</span></tt> : This is provided as the &#8220;count&#8221; argument to
<tt class="docutils literal"><span class="pre">.start</span></tt> , and contains the &#8220;object counter&#8221; for this
object. This is incremented for each new object which is created by the
receive Banana code. This is similar to (but not always the same as) the
OPEN-count. Containers should call <tt class="docutils literal"><span class="pre">self.protocol.setObject</span></tt> to
register a Deferred during <tt class="docutils literal"><span class="pre">start</span></tt> , then call it again in
<tt class="docutils literal"><span class="pre">receiveClose</span></tt> with the real (finished) object. It is sometimes
also included in a debug message.</li>
<li><tt class="docutils literal"><span class="pre">.broker</span></tt> : PB objects are given .broker, which is exactly
equal to the .protocol attribute. The synonym exists because it makes
several PB routines easier to read.</li>
</ul>
<p>Each Unslicer handles a single &#8220;OPEN sequence&#8221; , which starts with an
OPEN token and ends with a CLOSE token.</p>
<div class="section" id="creation">
<h4>Creation<a class="headerlink" href="#creation" title="Permalink to this headline">¶</a></h4>
<p>Acceptance of the OPEN token simply sets a flag to indicate that we are
in the Index Phase. (The OPEN token might not be accepted: it is submitted
to checkToken for approval first, as described below). During the Index
Phase, all tokens are appended to the current <tt class="docutils literal"><span class="pre">opentype</span></tt> list and
handed as a tuple to the top-most Unslicer&#8217;s <tt class="docutils literal"><span class="pre">doOpen</span></tt> method.
This method can do one of the following things:</p>
<ul class="simple">
<li>Return a new Unslicer object. It does this when there are enough index
tokens to specify a new Unslicer. The new child is pushed on top of the
Unslicer stack (Banana.receiveStack) and initialized by calling the
<tt class="docutils literal"><span class="pre">start</span></tt> method described below. This ends the Index Phase.</li>
<li>Return None. This indicates that more index tokens are required. The
Banana protocol object simply remains in the Index Phase and continues to
accumulate index tokens.</li>
<li>Raise a Violation. If the open type is unrecognized, then a Violation
is a good way to indicate it.</li>
</ul>
<p>When a new Unslicer object is pushed on the top of the stack, it has its``.start`` method called, in which it has an opportunity to create
whatever internal state is necessary to record the incoming content tokens.
Each created object will have a separate Unslicer instance. The start method
can run normally, or raise a Violation exception.</p>
<p><tt class="docutils literal"><span class="pre">.start</span></tt> is distinct from the Unslicer&#8217;s constructor function
to minimize the parameter-passing requirements for doOpen() and friends. It
is also conceivable that keeping arguments out of <tt class="docutils literal"><span class="pre">__init__</span></tt>
would make it easier to use adapters in this context, although it is not
clear why that might be useful on the Unslicing side. TODO: consider merging``.start`` into the constructor.</p>
<p>This Unslicer is responsible for all incoming tokens until either 1: it
pushes a new one on the stack, or 2: it receives a CLOSE token.</p>
</div>
<div class="section" id="checktoken">
<h4>checkToken<a class="headerlink" href="#checktoken" title="Permalink to this headline">¶</a></h4>
<p>Each token starts with a length sequence, up to 64 bytes which are turned
into an integer. This is followed by a single type byte, distinguished from
the length bytes by having the high bit set (the type byte is always 0x80 or
greater). When the typebyte is received, the topmost Unslicer is asked about
its suitability by calling the <tt class="docutils literal"><span class="pre">.checkToken</span></tt> method. (note that
CLOSE and ABORT tokens are always legal, and are not submitted to
checkToken). Both the typebyte and the header&#8217;s numeric value are passed to
this methoed, which is expected to do one of the following:</p>
<ul class="simple">
<li>Return None to indicate that the token and the header value are
acceptable.</li>
<li>Raise a <tt class="docutils literal"><span class="pre">Violation</span></tt> exception to reject the token or the
header value. This will cause the remainder of the current OPEN sequence
to be discarded (all tokens through the matching CLOSE token). Unslicers
should raise this if their constraints will not accept the incoming
object: for example a constraint which is expecting a series of integers
can accept INT/NEG/LONGINT/LONGNEG tokens and reject
OPEN/STRING/VOCAB/FLOAT tokens. They should also raise this if the header
indicates, e.g., a STRING which is longer than the constraint is willing
to accept, or a LONGINT/LONGNEG which is too large. The topmost Unslicer
(the same one which raised Violation) will receive (through its
<tt class="docutils literal"><span class="pre">.receiveChild</span></tt> method) an UnbananaFailure object which
encapsulates the reason for the rejection</li>
</ul>
<p>If the token sequence is in the &#8220;index phase&#8221; (i.e. it is just after
an OPEN token and a new Unslicer has not yet been pushed), then instead of``.checkToken`` the top unslicer is sent``.openerCheckToken`` . This method behaves just like checkToken,
but in addition to the type byte it is also given the opentype list (which
is built out of all the index tokens received during this index phase).</p>
</div>
<div class="section" id="receivechild">
<h4>receiveChild<a class="headerlink" href="#receivechild" title="Permalink to this headline">¶</a></h4>
<p>If the type byte is accepted, and the size limit is obeyed, then the rest
of the token is read and a finished (primitive) object is created: a string
or number (TODO: maybe add boolean and None). This object is handed to the
topmost Unslicer&#8217;s <tt class="docutils literal"><span class="pre">.receiveChild</span></tt> method, where again it is has
a few options:</p>
<ul class="simple">
<li>Run normally: if the object is acceptable, it should append or record
it somehow.</li>
<li>Raise Violation, just like checkToken.</li>
<li>invoke <tt class="docutils literal"><span class="pre">self.abort</span></tt> , which does
<tt class="docutils literal"><span class="pre">protocol.abandonUnslicer</span></tt></li>
</ul>
<p>If the child is handed an UnbananaFailure object, and it wishes to pass
it upwards to its parent, then <tt class="docutils literal"><span class="pre">self.abort</span></tt> is the appropriate
thing to do. Raising a Violation will accomplish the same thing, but with a
new UnbananaFailure that describes the exception raised here instead of the
one raised by a child object. It is bad to both call <tt class="docutils literal"><span class="pre">abort</span></tt> and
raise an exception.</p>
</div>
<div class="section" id="finishing">
<h4>Finishing<a class="headerlink" href="#finishing" title="Permalink to this headline">¶</a></h4>
<p>When the CLOSE token arrives, the Unslicer will have its``.receiveClose`` method called. This is expected to do:</p>
<ul class="simple">
<li>Return an object: this object is the finished result of the
deserialization process. It will be passed to <tt class="docutils literal"><span class="pre">.receiveChild</span></tt>
of the parent Unslicer.</li>
<li>Return a Deferred: this indicates that the object cannot be created
yet (tuples that contain references to an enclosing tuple, for example).
The Deferred will be fired (with the object) when it completes.</li>
<li>Raise Violation</li>
</ul>
<p>After receiveClose has finished, the child is told to clean up by calling
its <tt class="docutils literal"><span class="pre">.finish</span></tt> method. This can complete normally or raise a
Violation.</p>
<p>Then, the old top-most Unslicer is popped from the stack and discarded.
Its parent is now the new top-most Unslicer, and the newly-unserialized
object is given to it with the <tt class="docutils literal"><span class="pre">.receiveChild</span></tt> method. Note that
this method is used to deliver both primitive objects (from raw tokens)*and* composite objects (from other Unslicers).</p>
</div>
</div>
<div class="section" id="error-handling">
<h3>Error Handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h3>
<p>Schemas are enforced by Constraint objects which are given an opportunity
to pass judgement on each incoming token. When they do not like something
they are given, they respond by raising a <tt class="docutils literal"><span class="pre">Violation</span></tt> exception.
The Violation exception is sometimes created with an argument that describes
the reason for the rejection, but frequently it is just a bare exception.
Most Violations are raised by the <tt class="docutils literal"><span class="pre">checkOpentype</span></tt> and``checkObject`` methods of the various classes in``schema.py`` .</p>
<p>Violations which occur in an Unslicer can be confined to a single
sub-tree of the object graph. The object being deserialized (and all of its
children) is abandoned, and all remaining tokens for that object are
discarded. However, the parent object (to which the abandoned object would
have been given) gets to decide what happens next: it can either fail
itself, or absorb the failure (much like an exception handler can choose to
re-raise the exception or eat it).</p>
<p>When a Violation occurs, it is wrapped in an <tt class="docutils literal"><span class="pre">UnbananaFailure</span></tt>
object (just like Deferreds wrap exceptions in Failure objects). The
UnbananaFailure behaves like a regular``twisted.python.failure.Failure`` object, except that it has an
attribute named <tt class="docutils literal"><span class="pre">.where</span></tt> which indicate the object-graph pathname
where the problem occurred.</p>
<p>The Unslicer which caused the Violation is given a chance to do cleanup
or error-reporting by invoking its <tt class="docutils literal"><span class="pre">reportViolation</span></tt> method. It
is given the UnbananaFailure so it can modify or copy it. The default
implementation simply returns the is expected to return the UnbananaFailure
it was given, but it is also allowed to return a different one. It must
return an UnbananaFailure: it cannot ignore the Violation by returning None.
This method should not raise any exceptions: doing so will cause the
connection to be dropped.</p>
<p>The UnbananaFailure returned by <tt class="docutils literal"><span class="pre">reportViolation</span></tt> is passed up
the Unslicer stack in lieu of an actual object. Most Unslicers have code in
their <tt class="docutils literal"><span class="pre">receiveChild</span></tt> methods to detect an UnbananaFailure and
trigger an abort (<tt class="docutils literal"><span class="pre">propagateUnbananaFailures</span></tt> ), which causes all
further tokens of the sub-tree to be discarded. The connection is not
dropped. Unslicers which partition their children&#8217;s sub-graphs (like the
PBRootUnslicer, for which each child is a separate operation) can simply
ignore the UnbananaFailure, or respond to it by sending an error message to
the other end.</p>
<p>Other exceptions may occur during deserialization. These indicate coding
errors or severe protocol violations and cause the connection to be dropped
(they are not caught by the Banana code and thus propagate all the way up to
the reactor, which drops the socket). The exception is logged on the local
side with <tt class="docutils literal"><span class="pre">log.err</span></tt> , but the remote end will not be told any
reason for the disconnection. The banana code uses the BananaError exception
to indicate protocol violations, but others may be encountered.</p>
<p>The Banana object can also choose to respond to Violations by terminating
the connection. For example, the <tt class="docutils literal"><span class="pre">.hangupOnLengthViolation</span></tt> flag
causes string-too-long violations to be raised directly instead of being
handled, which will cause the connection to be dropped (as it occurs in the
dataReceived method).</p>
</div>
<div class="section" id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>The serialized form of <tt class="docutils literal"><span class="pre">[&quot;foo&quot;,(1,2)]</span></tt> is the
following token sequence: OPEN STRING(list) STRING(foo) OPEN STRING(tuple)
INT(1) INT(2) CLOSE CLOSE. In practice, the STRING(list) would really be
something like VOCAB(7), likewise the STRING(tuple) might be VOCAB(8). Here
we walk through how this sequence is processed.</p>
<p>The initial Unslicer stack consists of the single RootUnslicer``rootun`` .</p>
<div class="highlight-python"><pre>OPEN
  rootun.checkToken(OPEN) : must not raise Violation
  enter index phase

VOCAB(7)  (equivalent to STRING(list))
  rootun.openerCheckToken(VOCAB, ()) : must not raise Violation
  VOCAB token is looked up in .incomingVocabulary, turned into "list"
  rootun.doOpen(("list",)) : looks in UnslicerRegistry, returns ListUnslicer
  exit index phase
  the ListUnslicer is pushed on the stack
  listun.start()

STRING(foo)
  listun.checkToken(STRING, 3) : must return None
  string is assembled
  listun.receiveChild("foo") : appends to list

OPEN
  listun.checkToken(OPEN) : must not raise Violation
  enter index phase

VOCAB(8)  (equivalent to STRING(tuple))
  listun.openerCheckToken(VOCAB, ()) : must not raise Violation
  VOCAB token is looked up, turned into "tuple"
  listun.doOpen(("tuple",)) : delegates through:
                                 BaseUnslicer.open
                                 self.opener (usually the RootUnslicer)
                                 self.opener.open(("tuple",))
                              returns TupleUnslicer
  exit index phase
  TupleUnslicer is pushed on the stack
  tupleun.start()

INT(1)
  tupleun.checkToken(INT) : must not raise Violation
  integer is assembled
  tupleun.receiveChild(1) : appends to list

INT(2)
  tupleun.checkToken(INT) : must not raise Violation
  integer is assembled
  tupleun.receiveChild(2) : appends to list

CLOSE
  tupleun.receiveClose() : creates and returns the tuple (1,2)
                           (could also return a Deferred)
  TupleUnslicer is popped from the stack and discarded
  listun.receiveChild((1,2))

CLOSE
  listun.receiveClose() : creates and returns the list ["foo", (1,2)]
  ListUnslicer is popped from the stack and discarded
  rootun.receiveChild(["foo", (1,2)])</pre>
</div>
</div>
</div>
<div class="section" id="other-issues">
<h2>Other Issues<a class="headerlink" href="#other-issues" title="Permalink to this headline">¶</a></h2>
<div class="section" id="deferred-object-recreation-the-trouble-with-tuples">
<h3>Deferred Object Recreation: The Trouble With Tuples<a class="headerlink" href="#deferred-object-recreation-the-trouble-with-tuples" title="Permalink to this headline">¶</a></h3>
<p>Types and classes are roughly classified into containers and
non-containers. The containers are further divided into mutable and
immutable. Some examples of immutable containers are tuples and bound
methods. Lists and dicts are mutable containers. Ints and strings are
non-containers. Non-containers are always leaf nodes in the object
graph.</p>
<p>During unserialization, objects are in one of three states: uncreated,
referenceable (but not complete), and complete. Only mutable containers can
be referenceable but not complete: immutable containers have no intermediate
referenceable state.</p>
<p>Mutable containers (like lists) are referenceable but not complete during
traversal of their child nodes. This means those children can reference the
list without trouble.</p>
<p>Immutable containers (like tuples) present challenges when unserializing.
The object cannot be created until all its components are referenceable.
While it is guaranteed that these component objects will be complete before
the graph traversal exits the current node, the child nodes are allowed to
reference the current node during that traversal. The classic example is the
graph created by the following Python fragment:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="p">([],)</span>
<span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,))</span>
</pre></div>
</div>
<p>To handle these cases, the TupleUnslicer installs a Deferred into the
object table when it begins unserializing (in the .start method). When the
tuple is finally complete, the object table is updated and the Deferred is
fired with the new tuple.</p>
<p>Containers (both mutable and immutable) are required to pay attention to
the types of their incoming children and notice when they receive Deferreds
instead of normal objects. These containers are not complete (in the sense
described above) until those Deferreds have been replaced with referenceable
objects. When the container receives the Deferred, it should attach a
callback to it which will perform the replacement. In addition, immutable
containers should check after each update to see if all the Deferreds have
been cleared, and if so, complete their own object (and fire their own
Deferreds so any containers <em>they</em> are a child of may be updated
and/or completed).</p>
<p>TODO: it would be really handy to have the RootUnslicer do Deferred
Accounting: each time a Deferred is installed instead of a real object, add
its the graph-path to a list. When the Deferred fires and the object becomes
available, remove it. If deserialization completes and there are still
Deferreds hanging around, flag an error that points to the culprits instead
of returning a broken object.</p>
</div>
<div class="section" id="security-model">
<h3>Security Model<a class="headerlink" href="#security-model" title="Permalink to this headline">¶</a></h3>
<p>Having the whole Slicer stack get a chance to pass judgement on the
outbound object is very flexible. There are optimizations possibly because
of the fact that most Slicers don&#8217;t care, perhaps a separate stack for the
ones that want to participate, or a chained delegation function. The
important thing is to make sure that exception cases don&#8217;t leave a&#8221;taster&#8221; stranded on the stack when the object that put it there has
gone away.</p>
<p>On the receiving side, the top Unslicer gets to make a decision about the
token before its body has arrived (limiting memory exposure to no more than
65 bytes). In addition, each Unslicer receives component tokens one at a
time. This lets you catch the dangerous data before it gets turned into an
object. However, tokens are a pretty low-level place to do security checks.
It might be more useful to have some kind of &#8220;instance taster stack&#8221; ,
with tasters that are asked specifically about (class,state) pairs and
whether they should be turned into objects or not.</p>
<p>Because the Unslicers receive their data one token at a time, things like
InstanceUnslicer can perform security checks one attribute at a time.&#8221;traits&#8221; -style attribute constraints (see the Chaco project or the
PyCon-2003 presentation for details) can be implemented by having a
per-class dictionary of tests that attribute values must pass before they
will be accepted. The instance will only be created if all attributes fit
the constraints. The idea is to catch violations before any code is run on
the receiving side. Typical checks would be things like &#8221;.foo must be a number&#8221; , &#8221;.bar must not be an instance&#8221; , &#8221;.baz must implement the IBazzer interface&#8221; .</p>
<p>TODO: the rest of this section is somewhat out of date.</p>
<p>Using the stack instead of a single Taster object means that the rules
can be changed depending upon the context of the object being processed. A
class that is valid as the first argument to a method call may not be valid
as the second argument, or inside a list provided as the first argument. The
PBMethodArgumentsUnslicer could change the way its .taste method behaves as
its state machine progresses through the argument list.</p>
<p>There are several different ways to implement this Taster stack:</p>
<ul class="simple">
<li>Each object in the Unslicer stack gets to raise an exception if they
don&#8217;t like what they see: unanimous consent is required to let the token or
object pass</li>
<li>The top-most unslicer is asked, and it has the option of asking the
next slice down. It might not, allowing local &#8220;I&#8217;m sure this is safe&#8221;
classes to override higher-level paranoia.</li>
<li>Unslicer objects may add and remove Taster objects on a separate
stack. This is undoubtedly faster but must be done carefully to make sure
Tasters and Unslicers stay in sync.</li>
</ul>
<p>Of course, all this holds true for the sending side as well. A Slicer
could enforce a policy that no objects of type Foo will be sent while it is
on the stack.</p>
<p>It is anticipated that something like the current Jellyable/Unjellyable
classes will be created to offer control over the Slicer/Unslicers used to
handle instance of that class.</p>
<p>One eventual goal is to allow PB to implement E-like argument
constraints.</p>
</div>
<div class="section" id="streaming-slices">
<h3>Streaming Slices<a class="headerlink" href="#streaming-slices" title="Permalink to this headline">¶</a></h3>
<p>The big change from the old Jelly scheme is that now
serialization/unserialization is done in a more streaming format. Individual
tokens are the basic unit of information. The basic tokens are just numbers
and strings: anything more complicated (starting at lists) involves
composites of other tokens.</p>
<p>Producer/Consumer-oriented serialization means that large objects which
can&#8217;t fit into the socket buffers should not consume lots of memory, sitting
around in a serialized state with nowhere to go. This must be balanced
against the confusion caused by time-distributed serialization. PB method
calls must retain their current in-order execution, and it must not be
possible to interleave serialized state (big mess). One interesting
possibility is to allow multiple parallel SlicerStacks, with a
context-switch token to let the receiving end know when they should switch
to a different UnslicerStack. This would allow cleanly interleaved streams
at the token level. &#8220;Head-of-line blocking&#8221; is when a large request
prevents a smaller (quicker) one from getting through: grocery stores
attempt to relieve this frustration by grouping customers together by
expected service time (the express lane). Parallel stacks would allow the
sender to establish policies on immediacy versus minimizing context
switches.</p>
</div>
<div class="section" id="cbanana-cbananarun-runbananarun">
<h3>CBanana, CBananaRun, RunBananaRun<a class="headerlink" href="#cbanana-cbananarun-runbananarun" title="Permalink to this headline">¶</a></h3>
<p>Another goal of the Jelly+Banana-&gt;JustBanana change is the hope of
writing Slicers and Unslicers in C. The CBanana module should have C objects
(structs with function pointers) that can be looked up in a registry table
and run to turn python objects into tokens and vice versa. This ought to be
faster than running python code to implement the slices, at the cost of less
flexibility. It would be nice if the resulting tokens could be sent directly
to the socket at the C level without surfacing into python; barring this it
is probably a good idea to accumulate the tokens into a large buffer so the
code can do a few large writes instead of a gazillion small ones.</p>
<p>It ought to be possible to mix C and Python slices here: if the C code
doesn&#8217;t find the slice in the table, it can fall back to calling a python
method that does a lookup in an extensible registry.</p>
</div>
</div>
<div class="section" id="beyond-banana">
<h2>Beyond Banana<a class="headerlink" href="#beyond-banana" title="Permalink to this headline">¶</a></h2>
<p>Random notes and wild speculations: take everything beyond here with*two* grains of salt</p>
<div class="section" id="oldbanana-usage">
<h3>Oldbanana usage<a class="headerlink" href="#oldbanana-usage" title="Permalink to this headline">¶</a></h3>
<p>The oldbanana usage model has the layer above banana written in one of
two ways. The simple form is to use the <tt class="docutils literal"><span class="pre">banana.encode</span></tt> and <tt class="docutils literal"><span class="pre">banana.decode</span></tt> functions to turn an object into a
bytestream. This is used by twisted.spread.publish . The more flexible model
is to subclass Banana. The largest example of this technique is, of course,
twisted.spread.pb.Broker, but others which use it are twisted.trial.remote
and twisted.scripts.conch (which appears to use it over unix-domain
sockets).</p>
<p>Banana itself is a Protocol. The Banana subclass would generally override
the <tt class="docutils literal"><span class="pre">expressionReceived</span></tt> method, which receives s-expressions
(lists of lists). These are processed to figure out what method should be
called, etc (processing which only has to deal with strings, numbers, and
lists). Then the serialized arguments are sent through Unjelly to produce
actual objects.</p>
<p>On output, the subclass usually calls <tt class="docutils literal"><span class="pre">self.sendEncoded</span></tt> with
some set of objects. In the case of PB, the arguments to the remote method
are turned into s-expressions with jelly, then combined with the method
meta-data (object ID, method name, etc), then the whole request is sent to``sendEncoded`` .</p>
</div>
<div class="section" id="newbanana">
<h3>Newbanana<a class="headerlink" href="#newbanana" title="Permalink to this headline">¶</a></h3>
<p>Newbanana moves the Jelly functionality into a stack of Banana Slices,
and the lowest-level token-to-bytestream conversion into the new Banana
object. Instead of overriding <tt class="docutils literal"><span class="pre">expressionReceived</span></tt> , users could
push a different root Unslicer. to get more control over the receive
process.</p>
<p>Currently, Slicers call Banana.sendOpen/sendToken/sendClose/sendAbort, which
then creates bytes and does transport.write .</p>
<p>To move this into C, the transport should get to call CUnbanana.receiveToken
There should be CBananaUnslicers. Probably a parent.addMe(self) instead of
banana.stack.append(self), maybe addMeC for the C unslicer.</p>
<p>The Banana object is a Protocol, and has a dataReceived method. (maybe in
some C form, data could move directly from a CTransport to a CProtocol). It
parses tokens and hands them to its Unslicer stack. The root Unslicer is
probably created at connectionEstablished time. Subclasses of Banana could
use different RootUnslicer objects, or the users might be responsible for
setting up the root unslicer.</p>
<p>The Banana object is also created with a RootSlicer. Banana.writeToken
serializes the token and does transport.write . (a C form could have CSlicer
objects which hand tokens to a little CBanana which then hands bytes off to
a CTransport).</p>
<p>Doing the bytestream-to-Token conversion in C loses a lot of utility when
the conversion is done token at a time. It made more sense when a whole mess
of s-lists were converted at once.</p>
<p>All Slicers currently have a Banana pointer.. maybe they should have a
transport pointer instead? The Banana pointer is needed to get to top of the
stack.</p>
<p>want to be able to unserialize lists/tuples/dicts/strings/ints (&#8220;basic types&#8221; ) without surfacing into python. want to deliver the completed
object to a python function.</p>
</div>
<div class="section" id="streaming-methods">
<h3>Streaming Methods<a class="headerlink" href="#streaming-methods" title="Permalink to this headline">¶</a></h3>
<p>It would be neat if a PB method could indicate that it would like to
receive its arguments in a streaming fashion. This would involve calling the
method early (as soon as the objectID and method name were known), then
somehow feeding objects to it as they arrive. The object could return a
handler or consumer sub-object which would be fed as tokens arrive over the
wire. This consumer should have a way to enforce a constraint on its
input.</p>
<p>This consumer object sounds a lot like an Unslicer, so maybe the method
schema should indicate that the method will would like to be called right
away so it can return an Unslicer to be pushed on the stack. That Unslicer
could do whatever it wanted with the incoming tokens, and could enforce
constraints with the usual checkToken/doOpen/receiveChild/receiveClose
methods.</p>
<p>On the sending side, it would be neat to let a callRemote() invocation
provide a Producer or a generator that will supply data as the network
buffer becomes available. This could involve pushing a Slicer. Slicers are
generators.</p>
</div>
</div>
<div class="section" id="common-token-sequences">
<h2>Common token sequences<a class="headerlink" href="#common-token-sequences" title="Permalink to this headline">¶</a></h2>
<p>Any given Banana instance has a way to map objects to the Open Index
tuples needed to represent them, and a similar map from such tuples to
incoming object factories. These maps give rise to various &#8220;classes&#8221; of
objects, depending upon how widespread any particular object type is. A List
is a fairly common type of object, something you would expect to find
implemented in pretty much any high-level language, so you would expect a
Banana implementation in that language to be capable of accepting an (OPEN,
&#8216;list&#8217;) sequence. However, a Failure object (found in``twisted.python.failure`` , providing an asynchronous-friendly way
of reporting python exceptions) is both Python- and Twisted- specific. Is it
reasonable for one program to emit an (OPEN, &#8216;failure&#8217;) sequence and expect
another speaker of the generic &#8220;Banana&#8221; protocol to understand it?</p>
<p>This level of compatibility is (somewhat arbitrarily) named &#8220;dialect compatibility&#8221; . The set of acceptable sequences will depend upon many
things: the language in which the program at each end of the wire is
implemented, the nature of the higher-level software that is using Banana at
that moment (PB is one such layer), and application-specific registrations
that have been performed by the time the sequence is received (the set of``pb.Copyable`` sequences that can be received without error will
depend upon which <tt class="docutils literal"><span class="pre">RemoteCopyable</span></tt> class definitions and``registerRemoteCopy`` calls have been made).</p>
<p>Ideally, when two Banana instances first establish a connection, they
will go through a negotiation phase where they come to an agreement on what
will be sent across the wire. There are two goals to this negotiation:</p>
<ol class="arabic simple">
<li>least-surprise: if one side cannot handle a construct which the other
side might emit at some point in the future, it would be nice to know
about it up front rather than encountering a Violation or
connection-dropping BananaError later down the line. This could be
described as the &#8220;strong-typing&#8221; argument. It is important to note
that different arguments (both for and against strong typing) may exist
when talking about remote interfaces rather than local ones.</li>
<li>adapability: if one side cannot handle a newer construct, it may be
possible for the other side to back down to some simpler variation without
too much loss of data.</li>
</ol>
<p>Dialect negotiation is a very much still an active area of
development.</p>
<div class="section" id="base-python-types">
<h3>Base Python Types<a class="headerlink" href="#base-python-types" title="Permalink to this headline">¶</a></h3>
<p>The basic python types are considered &#8220;safe&#8221; : the code which is
invoked by their receipt is well-understood and there is no way to cause
unsafe behavior during unserialization. Resource consumption attacks are
mitigated by Constraints imposed by the receiving schema.</p>
<p>Note that the OPEN(dict) slicer is implemented with code that sorts the
list of keys before serializing them. It does this to provide deterministic
behavior and make testing easier.</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">IntType, LongType (small+)</th>
<th class="head">INT(value)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>IntType, LongType (small-)</td>
<td>NEG(value)</td>
</tr>
<tr><td>IntType, LongType (large+)</td>
<td>LONGINT(value)</td>
</tr>
<tr><td>IntType, LongType (large-)</td>
<td>LONGNEG(value)</td>
</tr>
<tr><td>FloatType</td>
<td>FLOAT(value)</td>
</tr>
<tr><td>StringType</td>
<td>STRING(value)</td>
</tr>
<tr><td>StringType (tokenized)</td>
<td>VOCAB(tokennum)</td>
</tr>
<tr><td>UnicodeType</td>
<td>OPEN(unicode) STRING(str.encode(&#8216;UTF-8&#8217;)) CLOSE</td>
</tr>
<tr><td>ListType</td>
<td>OPEN(list) elem.. CLOSE</td>
</tr>
<tr><td>TupleType</td>
<td>OPEN(tuple) elem.. CLOSE</td>
</tr>
<tr><td>DictType, DictionaryType</td>
<td>OPEN(dict) (key,value).. CLOSE</td>
</tr>
<tr><td>NoneType</td>
<td>OPEN(none) CLOSE</td>
</tr>
<tr><td>BooleanType</td>
<td>OPEN(boolean) INT(0/1) CLOSE</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="extended-unsafe-python-types">
<h3>Extended (unsafe) Python Types<a class="headerlink" href="#extended-unsafe-python-types" title="Permalink to this headline">¶</a></h3>
<p>To serialize arbitrary python object graphs (including instances)
requires that we allow more types in. This begins to get dangerous: with
complex graphs of inter-dependent objects, instances may need to be used (by
referencing objects) before they are fully initialized. A schema can be used
to make assertions about what object types live where, but in general the
contents of those objects are difficult to constrain.</p>
<p>For this reason, these types should only be used in places where you
trust the creator of the serialized stream (the same places where you would
be willing to use the standard Pickle module). Saving application state to
disk and reading it back at startup time is one example.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">InstanceType</th>
<th class="head">OPEN(instance) STRING(reflect.qual(class))
(attr,value).. CLOSE</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>ModuleType</td>
<td>OPEN(module) STRING(__name__) CLOSE</td>
</tr>
<tr><td>ClassType</td>
<td>OPEN(class) STRING(reflect.qual(class)) CLOSE</td>
</tr>
<tr><td>MethodType</td>
<td>OPEN(method) STRING(__name__) im_self im_class CLOSE</td>
</tr>
<tr><td>FunctionType</td>
<td>OPEN(function) STRING(module.__name__) CLOSE</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="pb-sequences">
<h3>PB Sequences<a class="headerlink" href="#pb-sequences" title="Permalink to this headline">¶</a></h3>
<p>See the <a class="reference internal" href="pb.html"><em>PB document</em></a> for details.</p>
</div>
<div class="section" id="unhandled-types">
<h3>Unhandled types<a class="headerlink" href="#unhandled-types" title="Permalink to this headline">¶</a></h3>
<p>The following types are not handled by any slicer, and will raise a
KeyError if one is referenced by an object being sliced. This technically
imposes a limit upon the kinds of objects that can be serialized, even by a&#8221;unsafe&#8221; serializer, but in practice it is not really an issue, as many
of these objects have no meaning outside the program invocation which
created them.</p>
<ul class="simple">
<li><ul class="first">
<li>types that might be nice to have</li>
</ul>
</li>
<li>ComplexType</li>
<li>SliceType</li>
<li>TypeType</li>
<li>XRangeType</li>
<li><ul class="first">
<li>types that aren&#8217;t really that useful</li>
</ul>
</li>
<li>BufferType</li>
<li>BuiltinFunctionType</li>
<li>BuiltinMethodType</li>
<li>CodeType</li>
<li>DictProxyType</li>
<li>EllipsisType</li>
<li>NotImplementedType</li>
<li>UnboundMethodType</li>
<li><ul class="first">
<li>types that are meaningless outside the creator</li>
</ul>
</li>
<li>TracebackType</li>
<li>FileType</li>
<li>FrameType</li>
<li>GeneratorType</li>
<li>LambdaType</li>
</ul>
</div>
<div class="section" id="unhandled-but-don-t-worry-about-it-types">
<h3>Unhandled (but don&#8217;t worry about it) types<a class="headerlink" href="#unhandled-but-don-t-worry-about-it-types" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">ObjectType</span></tt> is the root class of all other types. All objects
are known by some other type in addition to <tt class="docutils literal"><span class="pre">ObjectType</span></tt> , so the
fact that it is not handled explicitly does not matter.</p>
<p><tt class="docutils literal"><span class="pre">StringTypes</span></tt> is simply a list of <tt class="docutils literal"><span class="pre">StringType</span></tt> and``UnicodeType`` , so it does not need to be explicitly handled
either.</p>
</div>
<div class="section" id="internal-types">
<h3>Internal types<a class="headerlink" href="#internal-types" title="Permalink to this headline">¶</a></h3>
<p>The following sequences are internal.</p>
<p>The OPEN(vocab) sequence is used to update the forward compression
token-to-string table used by the VOCAB token. It is followed by a series of
number/string pairs. All numbers that appear in VOCAB tokens must be
associated with a string by appearing in the most recent OPEN(vocab)
sequence.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">The Banana Protocol</a><ul>
<li><a class="reference internal" href="#banana-tokens">Banana tokens</a></li>
<li><a class="reference internal" href="#serialization">Serialization</a><ul>
<li><a class="reference internal" href="#banana-slicers">Banana Slicers</a></li>
<li><a class="reference internal" href="#serialization-coherency">Serialization Coherency</a></li>
<li><a class="reference internal" href="#the-slicer-stack">The Slicer Stack</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deserialization">Deserialization</a><ul>
<li><a class="reference internal" href="#open-index-tokens-the-opentype">Open Index tokens: the Opentype</a></li>
<li><a class="reference internal" href="#unslicer-lifecycle">Unslicer Lifecycle</a><ul>
<li><a class="reference internal" href="#creation">Creation</a></li>
<li><a class="reference internal" href="#checktoken">checkToken</a></li>
<li><a class="reference internal" href="#receivechild">receiveChild</a></li>
<li><a class="reference internal" href="#finishing">Finishing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#error-handling">Error Handling</a></li>
<li><a class="reference internal" href="#example">Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-issues">Other Issues</a><ul>
<li><a class="reference internal" href="#deferred-object-recreation-the-trouble-with-tuples">Deferred Object Recreation: The Trouble With Tuples</a></li>
<li><a class="reference internal" href="#security-model">Security Model</a></li>
<li><a class="reference internal" href="#streaming-slices">Streaming Slices</a></li>
<li><a class="reference internal" href="#cbanana-cbananarun-runbananarun">CBanana, CBananaRun, RunBananaRun</a></li>
</ul>
</li>
<li><a class="reference internal" href="#beyond-banana">Beyond Banana</a><ul>
<li><a class="reference internal" href="#oldbanana-usage">Oldbanana usage</a></li>
<li><a class="reference internal" href="#newbanana">Newbanana</a></li>
<li><a class="reference internal" href="#streaming-methods">Streaming Methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#common-token-sequences">Common token sequences</a><ul>
<li><a class="reference internal" href="#base-python-types">Base Python Types</a></li>
<li><a class="reference internal" href="#extended-unsafe-python-types">Extended (unsafe) Python Types</a></li>
<li><a class="reference internal" href="#pb-sequences">PB Sequences</a></li>
<li><a class="reference internal" href="#unhandled-types">Unhandled types</a></li>
<li><a class="reference internal" href="#unhandled-but-don-t-worry-about-it-types">Unhandled (but don&#8217;t worry about it) types</a></li>
<li><a class="reference internal" href="#internal-types">Internal types</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../serializing.html"
                        title="previous chapter">Using Foolscap for Serialization</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="logfiles.html"
                        title="next chapter">Foolscap Logging Formats</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/specifications/banana.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="logfiles.html" title="Foolscap Logging Formats"
             >next</a> |</li>
        <li class="right" >
          <a href="../serializing.html" title="Using Foolscap for Serialization"
             >previous</a> |</li>
        <li><a href="../index.html">Foolscap v0.6.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Brian Warner.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>