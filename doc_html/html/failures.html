

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Foolscap Failure Reporting &mdash; Foolscap v0.6.1 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.6.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Foolscap v0.6.1 documentation" href="index.html" />
    <link rel="next" title="Flappserver: The Foolscap Application Server" href="flappserver.html" />
    <link rel="prev" title="Using Pass-By-Copy in Foolscap" href="copyable.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="flappserver.html" title="Flappserver: The Foolscap Application Server"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="copyable.html" title="Using Pass-By-Copy in Foolscap"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Foolscap v0.6.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="foolscap-failure-reporting">
<h1>Foolscap Failure Reporting<a class="headerlink" href="#foolscap-failure-reporting" title="Permalink to this headline">¶</a></h1>
<div class="section" id="signalling-remote-exceptions">
<h2>Signalling Remote Exceptions<a class="headerlink" href="#signalling-remote-exceptions" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">remote_</span></tt> -prefixed methods which Foolscap invokes, just
like their local counterparts, can either return a value or raise an
exception. Foolscap callers can use the normal Twisted conventions for
handling asyncronous failures: <tt class="docutils literal"><span class="pre">callRemote</span></tt> returns a Deferred
object, which will eventually either fire its callback function (if the
remote method returned a normal value), or its errback function (if the
remote method raised an exception).</p>
<p>There are several reasons that the Deferred returned
by <tt class="docutils literal"><span class="pre">callRemote</span></tt> might fire its errback:</p>
<ul class="simple">
<li>local outbound schema violation: the outbound method arguments did not
match the <tt class="docutils literal"><span class="pre">RemoteInterface</span></tt> that is in force. This is an
optional form of typechecking for remote calls, and is activated when
the remote object describes itself as conforming to a named
<tt class="docutils literal"><span class="pre">RemoteInterface</span></tt> which is also declared in a local class.
The local constraints are checked before the message is transmitted over
the wire. A constraint violation is indicated by
raising <tt class="docutils literal"><span class="pre">foolscap.schema.Violation</span></tt> , which is delivered
through the Deferred&#8217;s errback.</li>
<li>network partition: if the underlying TCP connection is lost before the
response has been received, the Deferred will errback with
a <tt class="docutils literal"><span class="pre">foolscap.ipb.DeadReferenceError</span></tt> exception. Several things
can cause this: the remote process shutting down (intentionally or
otherwise), a network partition or timeout, or the local process
shutting down (<tt class="docutils literal"><span class="pre">Tub.stopService</span></tt> will terminate all
outstanding remote messages before shutdown).</li>
<li>remote inbound schema violation: as the serialized method arguments were
unpacked by the remote process, one of them violated that processes
inbound <tt class="docutils literal"><span class="pre">RemoteInterface</span></tt> . This check serves to protect each
process from incorrect types which might either confuse the subsequent
code or consume a lot of memory. These constraints are enforced as the
tokens are read off the wire, and are signalled with the
same <tt class="docutils literal"><span class="pre">Violation</span></tt> exception as above (but this may be wrapped
in a <tt class="docutils literal"><span class="pre">RemoteException</span></tt> : see below).</li>
<li>remote method exception: if the <tt class="docutils literal"><span class="pre">remote_</span></tt> method raises an
exception, or returns a Deferred which subsequently fires its errback,
the remote side will send the caller that an exception occurred, and may
attempt to provide some information about this exception. The caller
will see an errback that may or may not attempt to replicate the remote
exception. This may be wrapped in a <tt class="docutils literal"><span class="pre">RemoteException</span></tt> . See
below for more details.</li>
<li>remote outbound schema violation: as the remote method&#8217;s return value is
serialized and put on the wire, the values are compared against the
return-value constraint (if a <tt class="docutils literal"><span class="pre">RemoteInterface</span></tt> is in
effect). If it does not match the constraint, a Violation will be raised
(but may be wrapped in a <tt class="docutils literal"><span class="pre">RemoteException</span></tt> ).</li>
<li>local inbound schema violation: when the serialized return value arrives
on the original caller&#8217;s side of the wire, the return-value constraint
of any effective <tt class="docutils literal"><span class="pre">RemoteInterface</span></tt> will be applied. This
protects the caller&#8217;s response code from unexpected values. Any
mismatches will be signalled with a Violation exception.</li>
</ul>
</div>
<div class="section" id="distinguishing-remote-exceptions">
<h2>Distinguishing Remote Exceptions<a class="headerlink" href="#distinguishing-remote-exceptions" title="Permalink to this headline">¶</a></h2>
<p>When a remote call fails, what should you do about it? There are several
factors to consider. Raising exceptions may be part of your remote API:
easy-to-use exceptions are a big part of Python&#8217;s success, and Foolscap
provides the tools to use them in a remote-calling environment as well.
Exceptions which are not meant to be part of the API frequently indicate
bugs, sometimes as precondition assertions (of which schema Violations are a
subset). It might be useful to react to the specific type of remote
exception, and/or it might be important to log as much information as
possible so a programmer can find out what went wrong, and in either case it
might be appropriate to react by falling back to some alternative code
path.</p>
<p>Good debuggability frequently requires at least one side of the connection
to get lots of information about errors that indicate possible bugs. Note
that the <tt class="docutils literal"><span class="pre">Tub.setOption(&quot;logLocalFailures&quot;,</span> <span class="pre">True)</span></tt>
and <tt class="docutils literal"><span class="pre">Tub.setOption(&quot;logRemoteFailures&quot;,</span> <span class="pre">True)</span></tt> options are
relevant: when these options are enabled, exceptions that are sent over the
wire (in one direction or the other) are recorded in the Foolscap log stream.
If you use exceptions as part of your regular remote-object API, you may want
to consider disabling both options. Otherwise the logs may be cluttered with
perfectly harmless exceptions.</p>
<p>Should your code pay attention to the details of a remote exception (other
than the fact that an exception happened at all)? There are roughly two
schools of thought:</p>
<ul class="simple">
<li>Distrust Outsiders: assume, like any sensible program which connects to
the internet, that the entire world is out to get you. Use external
services to the extent you can, but don&#8217;t allow them to confuse you or
trick you into some code path that will expose a vulnerability. Treat all
remote exceptions as identical.</li>
<li>&#8220;E&#8221; mode: treat external code with the same level of trust or distrust
that you would apply to local code. In the &#8220;E&#8221; programming language (which
inspires much of Foolscap&#8217;s feature set), each object is a separate trust
domain, and the only distinction made between &#8220;local&#8221; and &#8220;remote&#8221; objects
is that the former may be called synchronously, while the latter may become
partitioned. Treat remote exceptions just like local ones, interpreting
their type as best you can.</li>
</ul>
<p>From Foolscap&#8217;s point of view, what we care about is how to handle
exceptions raised by the remote code. When operating in the first mode,
Foolscap will merge all remote exceptions into a single exception type
named <tt class="docutils literal"><span class="pre">foolscap.api.RemoteException</span></tt> , which cannot be confused
with regular Python exceptions like <tt class="docutils literal"><span class="pre">KeyError</span></tt>
and <tt class="docutils literal"><span class="pre">AttributeError</span></tt> . In the second mode, Foolscap will try to
convert each remote exception into a corresponding local object, so that
error-handling code can catch e.g. <tt class="docutils literal"><span class="pre">KeyError</span></tt> and use it as part
of the remote API.</p>
<p>To tell Foolscap which mode you want to use,
call <tt class="docutils literal"><span class="pre">tub.setOption(&quot;expose-remote-exception-types&quot;,</span> <span class="pre">BOOL)</span></tt> , where
BOOL is either True (for the &#8220;E mode&#8221;) or False (for the &#8220;Distrust Outsiders&#8221;
mode). The default is True.</p>
<p>In &#8220;Distrust Outsiders&#8221; mode, a remote exception will cause the caller&#8217;s
errback handler to be called with a regular <tt class="docutils literal"><span class="pre">Failure</span></tt> object which
contains a <tt class="docutils literal"><span class="pre">foolscap.api.RemoteException</span></tt> , effectively hiding all
information about the nature of the problem except that it was caused by some
other system. Caller code can test for this with <tt class="docutils literal"><span class="pre">f.check</span></tt>
and <tt class="docutils literal"><span class="pre">f.trap</span></tt> as usual. If the caller&#8217;s code decides to investigate
further, it can use <tt class="docutils literal"><span class="pre">f.value.failure</span></tt> to obtain
the <tt class="docutils literal"><span class="pre">CopiedFailure</span></tt> (see below) that arrived from the remote
system. Note that schema Violations which are caught on the local system are
reported normally, whereas Violations which are caught on the remote system
are reported as RemoteExceptions.</p>
<p>In &#8220;E mode&#8221;, a remote exception will cause the errback handler to be
called with a <tt class="docutils literal"><span class="pre">CopiedFailure</span></tt> object.
This <tt class="docutils literal"><span class="pre">CopiedFailure</span></tt> will behave as much as possible like the
corresponding Failure from the remote side, given the limitations of the
serialization process (see below for details). In particular, if the remote
side raises e.g. a standard Python <tt class="docutils literal"><span class="pre">IndexError</span></tt> , the local side
can use <tt class="docutils literal"><span class="pre">f.trap(IndexError)</span></tt> to catch it. However, this same
f.trap call would also catch locally-generated IndexErrors, which could be
confusing.</p>
<div class="section" id="examples-distrust-outsiders">
<h3>Examples: Distrust Outsiders<a class="headerlink" href="#examples-distrust-outsiders" title="Permalink to this headline">¶</a></h3>
<p>Since Deferreds can be chained, it is quite common to see remote calls
sandwiched in the middle of two (possibly asynchronous) local calls. The
following snippet performs a local processing step, then asks a remote server
for information, then adds that information into a local database. All three
steps are asynchronous.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Example 1</span>
<span class="k">def</span> <span class="nf">get_and_store_record</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">local_db</span><span class="o">.</span><span class="n">getIDNumber</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">d</span><span class="o">.</span><span class="n">addCallback</span><span class="p">(</span><span class="k">lambda</span> <span class="n">idnum</span><span class="p">:</span> <span class="n">rref</span><span class="o">.</span><span class="n">callRemote</span><span class="p">(</span><span class="s">&quot;get_record&quot;</span><span class="p">,</span> <span class="n">idnum</span><span class="p">))</span>
    <span class="n">d</span><span class="o">.</span><span class="n">addCallback</span><span class="p">(</span><span class="k">lambda</span> <span class="n">record</span><span class="p">:</span> <span class="n">local_db</span><span class="o">.</span><span class="n">storeRecord</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">d</span>
</pre></div>
</div>
<p>To motivate an examination of error handling, we&#8217;ll extend this example to
use two separate servers for the record: if one of them doesn&#8217;t have it, we
ask the other. The first server might raise <tt class="docutils literal"><span class="pre">KeyError</span></tt> to tell us
it can&#8217;t find the record, or it might experience some other internal error,
or we might lose the connection to that server before it can get us an
answer: all three cases should prompt us to talk to the second server.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Example 2</span>
<span class="kn">from</span> <span class="nn">foolscap.api</span> <span class="kn">import</span> <span class="n">Tub</span><span class="p">,</span> <span class="n">RemoteException</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tub</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">setOption</span><span class="p">(</span><span class="s">&quot;expose-remote-exception-types&quot;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span> <span class="c"># Distrust Outsiders</span>
<span class="o">...</span>

<span class="k">def</span> <span class="nf">get_and_store_record</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">local_db</span><span class="o">.</span><span class="n">getIDNumber</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_record</span><span class="p">(</span><span class="n">idnum</span><span class="p">):</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="n">server1</span><span class="o">.</span><span class="n">callRemote</span><span class="p">(</span><span class="s">&quot;get_record&quot;</span><span class="p">,</span> <span class="n">idnum</span><span class="p">)</span> <span class="c"># could raise KeyError</span>
        <span class="k">def</span> <span class="nf">maybe_try_server2</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">trap</span><span class="p">(</span><span class="n">RemoteException</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">server2</span><span class="o">.</span><span class="n">callRemote</span><span class="p">(</span><span class="s">&quot;get_record&quot;</span><span class="p">,</span> <span class="n">idnum</span><span class="p">)</span> <span class="c"># or KeyError</span>
        <span class="n">d2</span><span class="o">.</span><span class="n">addErrback</span><span class="p">(</span><span class="n">maybe_try_server2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d2</span>
    <span class="n">d</span><span class="o">.</span><span class="n">addCallback</span><span class="p">(</span><span class="n">get_record</span><span class="p">)</span>
    <span class="n">d</span><span class="o">.</span><span class="n">addCallback</span><span class="p">(</span><span class="k">lambda</span> <span class="n">record</span><span class="p">:</span> <span class="n">local_db</span><span class="o">.</span><span class="n">storeRecord</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">d</span>
</pre></div>
</div>
<p>In this example, only a failure that occurs on server1 will cause the code
to attempt to use server2. A locally-triggered error will be trapped by the
first line of <tt class="docutils literal"><span class="pre">maybe_try_server2</span></tt> and will not proceed to the
second <tt class="docutils literal"><span class="pre">callRemote</span></tt> . This allows a more complex control flow like
the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Example 3</span>
<span class="k">def</span> <span class="nf">get_and_store_record</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">local_db</span><span class="o">.</span><span class="n">getIDNumber</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="c"># could raise IndexError</span>

    <span class="k">def</span> <span class="nf">get_record</span><span class="p">(</span><span class="n">idnum</span><span class="p">):</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="n">server1</span><span class="o">.</span><span class="n">callRemote</span><span class="p">(</span><span class="s">&quot;get_record&quot;</span><span class="p">,</span> <span class="n">idnum</span><span class="p">)</span> <span class="c"># or KeyError</span>
        <span class="k">def</span> <span class="nf">maybe_try_server2</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">trap</span><span class="p">(</span><span class="n">RemoteException</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">server2</span><span class="o">.</span><span class="n">callRemote</span><span class="p">(</span><span class="s">&quot;get_record&quot;</span><span class="p">,</span> <span class="n">idnum</span><span class="p">)</span> <span class="c"># or KeyError</span>
        <span class="n">d2</span><span class="o">.</span><span class="n">addErrback</span><span class="p">(</span><span class="n">maybe_try_server2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d2</span>
    <span class="n">d</span><span class="o">.</span><span class="n">addCallback</span><span class="p">(</span><span class="n">get_record</span><span class="p">)</span>

    <span class="n">d</span><span class="o">.</span><span class="n">addCallback</span><span class="p">(</span><span class="k">lambda</span> <span class="n">record</span><span class="p">:</span> <span class="n">local_db</span><span class="o">.</span><span class="n">storeRecord</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">ignore_unknown_names</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="n">f</span><span class="o">.</span><span class="n">trap</span><span class="p">(</span><span class="ne">IndexError</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&quot;Couldn&#39;t get ID for name, ignoring&quot;</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="n">d</span><span class="o">.</span><span class="n">addErrback</span><span class="p">(</span><span class="n">ignore_unknown_names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">failed</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;didn&#39;t get data!&quot;</span>
        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">RemoteException</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">failure</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">):</span>
                <span class="k">print</span> <span class="s">&quot;both servers claim to not have the record&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;both servers had error&quot;</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="k">print</span> <span class="s">&quot;local error&quot;</span>
        <span class="k">print</span> <span class="s">&quot;error details:&quot;</span><span class="p">,</span> <span class="n">f</span>
    <span class="n">d</span><span class="o">.</span><span class="n">addErrback</span><span class="p">(</span><span class="n">failed</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">d</span>
</pre></div>
</div>
<p>The final <tt class="docutils literal"><span class="pre">failed</span></tt> method will catch any unexpected error: this
is the place where you want to log enough information to diagnose a code bug.
For example, if the database fetch had returned a string, but the
RemoteInterface had declared <tt class="docutils literal"><span class="pre">get_record</span></tt> as taking an integer,
then the <tt class="docutils literal"><span class="pre">callRemote</span></tt> would signal a (local) Violation exception,
causing control to drop directly to the <tt class="docutils literal"><span class="pre">failed()</span></tt> error handler.
On the other hand, if the first server decided to throw a Violation on its
inbound argument, the <tt class="docutils literal"><span class="pre">callRemote</span></tt> would signal a RemoteException
(wrapping a Violation), and control would flow to
the <tt class="docutils literal"><span class="pre">maybe_try_server2</span></tt> fallback.</p>
<p>It is usually best to put the errback as close as possible to the call
which might fail, since this provides the highest &#8220;signal to noise ratio&#8221;
(i.e. it reduces the number of possibilities that the error-handler code must
handle). But it is frequently more convenient to place the errback later in
the Deferred chain, so it can be useful to distinguish between the
local <tt class="docutils literal"><span class="pre">IndexError</span></tt> and a remote exception of the same type. This
is the same decision that needs to be made with synchronous code: whether to
use lots of <tt class="docutils literal"><span class="pre">try:/except:</span></tt> blocks wrapped around individual method
calls, or to use one big block around a whole sequence of calls. Smaller
blocks will catch an exception sooner, but larger blocks are less effort to
write, and can be more appropriate, especially if you do not expect
exceptions to happen very often.</p>
<p>Note that if this example had used &#8220;E mode&#8221; and the first remote server
decided (perhaps maliciously) to raise <tt class="docutils literal"><span class="pre">IndexError</span></tt> , then the
client could be tricked into following the same ignore-unknown-names code
path that was meant to be reserved for a local database miss.</p>
<p>To examine the type of failure more closely, the error-handling code
should access the <tt class="docutils literal"><span class="pre">RemoteException</span></tt> &#8216;s <tt class="docutils literal"><span class="pre">.value.failure</span></tt>
attribute. By making the following change to <tt class="docutils literal"><span class="pre">maybe_try_server2</span></tt> ,
the behavior is changed to only query the second server in the specific case
of a remote <tt class="docutils literal"><span class="pre">KeyError</span></tt> . Other remote exceptions (and all local
exceptions) will skip the second query and signal an error
to <tt class="docutils literal"><span class="pre">failed()</span></tt> . You might want to do this if you believe that a
remote failure like <tt class="docutils literal"><span class="pre">AttributeError</span></tt> is worthy of error-logging
rather than fallback behavior.</p>
<div class="highlight-python"><pre># Example 4
        def maybe_try_server2(f):
            f.trap(RemoteException)
            if f.value.failure.check(KeyError):
                return server2.callRemote("get_record", idnum) # or KeyError
            return f</pre>
</div>
<p>Note that you should probably not use <tt class="docutils literal"><span class="pre">f.value.failure.trap</span></tt> ,
since if the exception type does not match, that will raise the inner
exception (i.e. the <tt class="docutils literal"><span class="pre">KeyError</span></tt> ) instead of
the <tt class="docutils literal"><span class="pre">RemoteException</span></tt> , potentially confusing subsequent
error-handling code.</p>
</div>
<div class="section" id="examples-e-mode">
<h3>Examples: E Mode<a class="headerlink" href="#examples-e-mode" title="Permalink to this headline">¶</a></h3>
<p>Systems which use a lot of remote exceptions as part of their
inter-process API can reduce the size of the remote-error-handling code by
switching modes, at the expense of risking confusion between local and remote
occurrences of the same exception type. In the following example, we use &#8220;E
Mode&#8221; and look for <tt class="docutils literal"><span class="pre">KeyError</span></tt> to indicate a
remote <tt class="docutils literal"><span class="pre">get_record</span></tt> miss.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Example 5</span>
<span class="kn">from</span> <span class="nn">foolscap.api</span> <span class="kn">import</span> <span class="n">Tub</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tub</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">setOption</span><span class="p">(</span><span class="s">&quot;expose-remote-exception-types&quot;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="c"># E Mode</span>
<span class="o">...</span>

<span class="k">def</span> <span class="nf">get_and_store_record</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">local_db</span><span class="o">.</span><span class="n">getIDNumber</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_record</span><span class="p">(</span><span class="n">idnum</span><span class="p">):</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="n">server1</span><span class="o">.</span><span class="n">callRemote</span><span class="p">(</span><span class="s">&quot;get_record&quot;</span><span class="p">,</span> <span class="n">idnum</span><span class="p">)</span> <span class="c"># or KeyError</span>
        <span class="k">def</span> <span class="nf">maybe_try_server2</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">trap</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">server2</span><span class="o">.</span><span class="n">callRemote</span><span class="p">(</span><span class="s">&quot;get_record&quot;</span><span class="p">,</span> <span class="n">idnum</span><span class="p">)</span> <span class="c"># or KeyError</span>
        <span class="n">d2</span><span class="o">.</span><span class="n">addErrback</span><span class="p">(</span><span class="n">maybe_try_server2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d2</span>
    <span class="n">d</span><span class="o">.</span><span class="n">addCallback</span><span class="p">(</span><span class="n">get_record</span><span class="p">)</span>

    <span class="n">d</span><span class="o">.</span><span class="n">addCallback</span><span class="p">(</span><span class="k">lambda</span> <span class="n">record</span><span class="p">:</span> <span class="n">local_db</span><span class="o">.</span><span class="n">storeRecord</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">ignore_unknown_names</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="n">f</span><span class="o">.</span><span class="n">trap</span><span class="p">(</span><span class="ne">IndexError</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&quot;Couldn&#39;t get ID for name, ignoring&quot;</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="n">d</span><span class="o">.</span><span class="n">addErrback</span><span class="p">(</span><span class="n">ignore_unknown_names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">failed</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;didn&#39;t get data!&quot;</span>
        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">):</span>
            <span class="c"># don&#39;t bother showing details</span>
            <span class="k">print</span> <span class="s">&quot;both servers claim to not have the record&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># show details by printing &quot;f&quot;, the Failure instance</span>
            <span class="k">print</span> <span class="s">&quot;other error&quot;</span><span class="p">,</span> <span class="n">f</span>
    <span class="n">d</span><span class="o">.</span><span class="n">addErrback</span><span class="p">(</span><span class="n">failed</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">d</span>
</pre></div>
</div>
<p>In this example, <tt class="docutils literal"><span class="pre">KeyError</span></tt> is part of the
remote <tt class="docutils literal"><span class="pre">get_record</span></tt> method&#8217;s API: it either returns the data, or
it raises KeyError, and anything else indicates a bug. The caller explicitly
catches KeyError and responds by either falling back to the second server
(the first time) or announcing a servers-have-no-record error (if the
fallback failed too). But if something else goes wrong, the client indicates
a different error, along with the exception that triggered it, so that a
programmer can investigate.</p>
<p>The remote error-handling code is slightly simpler, relative to the
identical behavior expressed in Example 4,
since <tt class="docutils literal"><span class="pre">maybe_try_server2</span></tt> only needs to
use <tt class="docutils literal"><span class="pre">f.trap(KeyError)</span></tt> , instead of needing to unwrap
a <tt class="docutils literal"><span class="pre">RemoteException</span></tt> first. But when this error-handling code is at
the end of a larger block (such as the <tt class="docutils literal"><span class="pre">f.trap(IndexError)</span></tt>
in <tt class="docutils literal"><span class="pre">ignore_unknown_names()</span></tt> , or the <tt class="docutils literal"><span class="pre">f.check(KeyError)</span></tt>
in <tt class="docutils literal"><span class="pre">failed()</span></tt> ), it is vulnerable to confusion:
if <tt class="docutils literal"><span class="pre">local_db.getIDNumber</span></tt> raised <tt class="docutils literal"><span class="pre">KeyError</span></tt> (instead of
the expected <tt class="docutils literal"><span class="pre">IndexError</span></tt> ), or if the remote server
raised <tt class="docutils literal"><span class="pre">IndexError</span></tt> (instead of <tt class="docutils literal"><span class="pre">KeyError</span></tt> ), then the
error-handling logic would follow the wrong path.</p>
</div>
<div class="section" id="default-mode">
<h3>Default Mode<a class="headerlink" href="#default-mode" title="Permalink to this headline">¶</a></h3>
<p>Exception modes were introduced in Foolscap-0.4.0 . Releases before that
only offered &#8220;E mode&#8221;. The default in 0.4.0 is &#8220;E mode&#8221;
(expose-remote-exception-types=True), to retain compatibility with the
exception-handling code in existing applications. A future release of
Foolscap may change the default mode to expose-remote-exception-types=False,
since it seems likely that apps written in this style are less likely to be
confused by remote exceptions of unexpected types.</p>
</div>
</div>
<div class="section" id="copiedfailures">
<h2>CopiedFailures<a class="headerlink" href="#copiedfailures" title="Permalink to this headline">¶</a></h2>
<p>Twisted uses the <tt class="docutils literal"><span class="pre">twisted.python.failure.Failure</span></tt> class to
encapsulate Python exceptions in an instance which can be passed around,
tested, and examined in an asynchronous fashion. It does this by copying much
of the information out of the original exception context (including a stack
trace and the exception instance itself) into the <tt class="docutils literal"><span class="pre">Failure</span></tt>
instance. When an exception is raised during a Deferred callback function, it
is converted into a Failure instance and passed to the next errback handler
in the chain.</p>
<p>When <tt class="docutils literal"><span class="pre">RemoteReference.callRemote</span></tt> needs to transport
information about a remote exception over the wire, it uses the same
convention. However, Failure objects cannot be cleanly serialized and sent
over the wire, because they contain references to local state which cannot be
precisely replicated on a different system (stack frames and exception
classes). So, when an exception happens on the remote side of
a <tt class="docutils literal"><span class="pre">callRemote</span></tt> invocation, and the exception-handling mode passes
the remote exception back to the calling code somehow, that code will receive
a <tt class="docutils literal"><span class="pre">CopiedFailure</span></tt> instance instead.</p>
<p>In &#8220;E mode&#8221;, the <tt class="docutils literal"><span class="pre">callRemote</span></tt> &#8216;s errback function will receive
a <tt class="docutils literal"><span class="pre">CopiedFailure</span></tt> in response to a remote exception, and will
receive a regular <tt class="docutils literal"><span class="pre">Failure</span></tt> in response to locally-generated
exceptions. In &#8220;Distrust Outsiders&#8221; mode, the errback will always receive a
regular <tt class="docutils literal"><span class="pre">Failure</span></tt> , but
if <tt class="docutils literal"><span class="pre">f.check(foolscap.api.RemoteException)</span></tt> is True, then
the <tt class="docutils literal"><span class="pre">CopiedFailure</span></tt> can be obtained
with <tt class="docutils literal"><span class="pre">f.value.failure</span></tt> and examined further.</p>
<p><tt class="docutils literal"><span class="pre">CopiedFailure</span></tt> is designed to behave very much like a
regular <tt class="docutils literal"><span class="pre">Failure</span></tt> object. The <tt class="docutils literal"><span class="pre">check</span></tt>
and <tt class="docutils literal"><span class="pre">trap</span></tt> methods work on <tt class="docutils literal"><span class="pre">CopiedFailure</span></tt> s just like
they do on <tt class="docutils literal"><span class="pre">Failure</span></tt> s.</p>
<p>However, all of the Failure&#8217;s attributes must be converted into strings
for serialization. As a result, the original <tt class="docutils literal"><span class="pre">.value</span></tt> attribute
(which contains the exception instance, which might contain additional
information about the problem) is replaced by a stringified representation,
which tends to lose information. The frames of the original stack trace are
also replaced with a string, so they can be printed but not examined. The
exception class is also passed as a string (using
Twisted&#8217;s <tt class="docutils literal"><span class="pre">reflect.qual</span></tt> fully-qualified-name utility),
but <tt class="docutils literal"><span class="pre">check</span></tt> and <tt class="docutils literal"><span class="pre">trap</span></tt> both compare by string name
instead of object equality, so most applications won&#8217;t notice the
difference.</p>
<p>The default behavior of CopiedFailure is to include a string copy of the
stack trace, generated with <tt class="docutils literal"><span class="pre">printTraceback()</span></tt> , which will include
lines of source code when available. To reduce the amount of information sent
over the wire, stack trace strings larger than about 2000 bytes are truncated
in a fashion that tries to preserve the top and bottom of the stack.</p>
<div class="section" id="unsafetracebacks">
<h3>unsafeTracebacks<a class="headerlink" href="#unsafetracebacks" title="Permalink to this headline">¶</a></h3>
<p>Applications which consider their lines of source code or their
exceptions&#8217; list of (filename, line number) tuples to be sensitive
information can set the &#8220;unsafeTracebacks&#8221; flag in their Tub to False; the
server will then remove stack information from the CopiedFailure objects it
sends to other systems.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t</span> <span class="o">=</span> <span class="n">Tub</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">unsafeTracebacks</span> <span class="o">=</span> <span class="bp">False</span>
</pre></div>
</div>
<p>When unsafeTracebacks is False, the <tt class="docutils literal"><span class="pre">CopiedFailure</span></tt> will only
contain the stringified exception type, value, and parent class names.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Foolscap Failure Reporting</a><ul>
<li><a class="reference internal" href="#signalling-remote-exceptions">Signalling Remote Exceptions</a></li>
<li><a class="reference internal" href="#distinguishing-remote-exceptions">Distinguishing Remote Exceptions</a><ul>
<li><a class="reference internal" href="#examples-distrust-outsiders">Examples: Distrust Outsiders</a></li>
<li><a class="reference internal" href="#examples-e-mode">Examples: E Mode</a></li>
<li><a class="reference internal" href="#default-mode">Default Mode</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copiedfailures">CopiedFailures</a><ul>
<li><a class="reference internal" href="#unsafetracebacks">unsafeTracebacks</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="copyable.html"
                        title="previous chapter">Using Pass-By-Copy in Foolscap</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="flappserver.html"
                        title="next chapter">Flappserver: The Foolscap Application Server</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/failures.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="flappserver.html" title="Flappserver: The Foolscap Application Server"
             >next</a> |</li>
        <li class="right" >
          <a href="copyable.html" title="Using Pass-By-Copy in Foolscap"
             >previous</a> |</li>
        <li><a href="index.html">Foolscap v0.6.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Brian Warner.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>