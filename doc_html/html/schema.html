

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Foolscap Schemas &mdash; Foolscap v0.6.1 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.6.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Foolscap v0.6.1 documentation" href="index.html" />
    <link rel="next" title="Using Foolscap for Serialization" href="serializing.html" />
    <link rel="prev" title="Foolscap Logging" href="logging.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="serializing.html" title="Using Foolscap for Serialization"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="logging.html" title="Foolscap Logging"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Foolscap v0.6.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="foolscap-schemas">
<h1>Foolscap Schemas<a class="headerlink" href="#foolscap-schemas" title="Permalink to this headline">¶</a></h1>
<p><em>NOTE! This is all preliminary and is more an exercise in semiconscious protocol design than anything else. Do not believe this document. This sentence is lying. So there.</em></p>
<div class="section" id="existing-constraint-classes">
<h2>Existing <tt class="docutils literal"><span class="pre">Constraint</span></tt>  classes<a class="headerlink" href="#existing-constraint-classes" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="8%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">class name</th>
<th class="head">shortcut</th>
<th class="head"></th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">Any()</span></tt></td>
<td></td>
<td>accept anything</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">StringConstraint(maxLength=1000)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">str</span></tt></td>
<td>string of up to maxLength characters (maxLength=None means
unlimited), or a VOCAB sequence of any length</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">IntegerConstraint(maxBytes=-1)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">int</span></tt></td>
<td>integer. maxBytes=-1 means s_int32_t, =N means LONGINT which can be
expressed in N or fewer bytes (i.e. abs(num) &lt; 2**(8*maxBytes)),
=None means unlimited. NOTE: shortcut &#8216;long&#8217; is like shortcut &#8216;int&#8217; but
maxBytes=1024.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">NumberConstraint(maxBytes=1024)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">float</span></tt></td>
<td>integer or float. Integers are limited by maxBytes as in
<tt class="docutils literal"><span class="pre">IntegerConstraint</span></tt> , floats are fixed size.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">BooleanConstraint(value=None)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">bool</span></tt></td>
<td>True or False. If value=True, only accepts True. If value=False,
only accepts False. NOTE: value= is a very silly parameter.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">InterfaceConstraint(iface)</span></tt></td>
<td>Interface</td>
<td>TODO. UNSAFE. Accepts an instance which claims to implement the given
Interface. The shortcut is simply any Interface subclass.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">ClassConstraint</span></tt></td>
<td>Class</td>
<td>TODO. UNSAFE. Accepts an instance which claims to be of the given
class name. The shortcut is simply any (old-style) class object.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">PolyConstraint(*alternatives)</span></tt></td>
<td>(alt1, alt2)</td>
<td>Accepts any object which obeys at least one of the alternative
constraints provided. Implements a logical OR function of the given
constraints. Also known as <tt class="docutils literal"><span class="pre">ChoiceOf</span></tt> .</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">TupleConstraint(*elemConstraints)</span></tt></td>
<td></td>
<td>Accepts a tuple of fixed length with elements that obey the given
constraints. Also known as <tt class="docutils literal"><span class="pre">TupleOf</span></tt> .</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">ListConstraint(elemConstraint,</span> <span class="pre">maxLength=30)</span></tt></td>
<td></td>
<td>Accepts a list of up to maxLength items, each of which obeys the
element constraint provided. Also known as <tt class="docutils literal"><span class="pre">ListOf</span></tt> .</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">DictConstraint(keyConstraint,</span> <span class="pre">valueConstraint,</span> <span class="pre">maxKeys=30)</span></tt></td>
<td></td>
<td>Accepts a dictionary of up to maxKeys items. Each key must obey
keyConstraint and each value must obey valueConstraint. Also known
as <tt class="docutils literal"><span class="pre">DictOf</span></tt> .</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">AttributeDictConstraint(*attrTuples,</span> <span class="pre">**kwargs)</span></tt></td>
<td></td>
<td>Constrains dictionaries used to describe instance attributes, as used
by RemoteCopy. Each attrTuple is a pair of (attrname, constraint), used
to constraint individual named attributes. kwargs[&#8216;attributes&#8217;]
provides the same control. kwargs[&#8216;ignoreUnknown&#8217;] is a boolean flag
which indicates that unknown attributes in inbound state should simply
be dropped. kwargs[&#8216;acceptUnknown&#8217;] indicates that unknown attributes
should be accepted into the instance state dictionary.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">RemoteMethodSchema(method=None,</span> <span class="pre">_response=None,</span> <span class="pre">__options=[],</span> <span class="pre">**kwargs)</span></tt></td>
<td></td>
<td><p class="first">Constrains arguments and return value of a single remotely-invokable
method. If method= is provided, the <tt class="docutils literal"><span class="pre">inspect</span></tt>  module is used</p>
<blockquote class="last">
<div>to extract constraints from the method itself (positional arguments are
not allowed, default values of keyword arguments provide constraints for
each argument, the results of running the method provide the return value
constraint). If not, most kwargs items provide constraints for method
arguments, _response provides a constraint for the return value.
__options and additional kwargs keys provide neato whiz-bang future
expansion possibilities.</div></blockquote>
</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">Shared(constraint,</span> <span class="pre">refLimit=None)</span></tt></td>
<td></td>
<td>TODO. Allows objects with refcounts no greater than refLimit (=None
means unlimited). Wraps another constraint, which the object must obey.
refLimit=1 rejects shared objects.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">Optional(constraint,</span> <span class="pre">default)</span></tt></td>
<td></td>
<td>TODO. Can be used to tag Copyable attributes or (maybe) method
arguments. Wraps another constraint. If an object is provided, it must
obey the constraint. If not provided, the default value will be given in
its place.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">FailureConstraint()</span></tt></td>
<td></td>
<td>Constrains the contents of a CopiedFailure.</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><pre>"""

RemoteReference objects should all be tagged with interfaces that they
implement, which point to representations of the method schemas. When a
remote method is called, Foolscap should look up the appropriate method and
serialize the argument list accordingly.

We plan to eliminate positional arguments, so local RemoteReferences use
their schema to convert callRemote calls with positional arguments to
all-keyword arguments before serialization.

Conversion to the appropriate version interface should be handled at the
application level.  Eventually, with careful use of twisted.python.context,
we might be able to provide automated tools for helping application authors
automatically convert interface calls and isolate version-conversion code,
but that is probably pretty hard.

"""


class Attributes:
    def __init__(self,*a,**k):
        pass

X = Attributes(
    ('hello', str),
    ('goodbye', int),

    # Allow the possibility of multiple or circular references.  The default
    # is to make multiple copies to avoid making the serializer do extra
    # work.
    ('next', Shared(Narf)),

    ('asdf', ListOf(Narf, maxLength=30)),
    ('fdsa', (Narf, String(maxLength=5), int)),
    ('qqqq', DictOf(str, Narf, maxKeys=30)),
    ('larg', AttributeDict(('A', int),
                           ('X', Number),
                           ('Z', float))),
    Optional("foo", str),
    Optional("bar", str, default=None),
    ignoreUnknown=True,
    )

X = Attributes(
    attributes={ 'hello': str,     # this form doesn't allow Optional()
                 'goodbye': int,
               },
    Optional("foo", str),  # but both can be used at once
    ignoreUnknown=True)

class Narf(Remoteable):
    # step 1
    __schema__ = X
    # step 2 (possibly - this loses information)
    class schema:
        hello = str
        goodbye = int
        class add:
            x = Number
            y = Number
            __return__ = Copy(Number)

        class getRemoteThingy:
            fooID = Arg(WhateverID, default=None)
            barID = Arg(WhateverID, default=None)
            __return__ = Reference(Narf)

    # step 3 - this is the only example that shows argument order, which we
    # _do_ need in order to translate positional arguments to callRemote, so
    # don't take the nested-classes example too seriously.

    schema = """
    int add (int a, int b)
    """

    # Since the above schema could also be used for Formless, or possibly for
    # World (for state) we can also do:

    class remote_schema:
        """blah blah
        """

    # You could even subclass that from the other one...

    class remote_schema(schema):
        dontUse = 'hello', 'goodbye'


    def remote_add(self, x, y):
        return x + y

    def rejuvinate(self, deadPlayer):
        return Reference(deadPlayer.bringToLife())

    # "Remoteable" is a new concept - objects which may be method-published
    # remotely _or_ copied remotely.  The schema objects support both method
    # / interface definitions and state definitions, so which one gets used
    # can be defined by the sending side as to whether it sends a
    # Copy(theRemoteable) or Reference(theRemoteable)

    # (also, with methods that are explicitly published by a schema there is
    # no longer technically any security need for the remote_ prefix, which,
    # based on past experience can be kind of annoying if you want to
    # provide the same methods locally and remotely)

    # outstanding design choice - Referenceable and Copyable are subclasses
    # of Remoteable, but should they restrict the possibility of sending it
    # the other way or

    def getPlayerInfo(self, playerID):
        return CopyOf(self.players[playerID])

    def getRemoteThingy(self, fooID, barID):
        return ReferenceTo(self.players[selfPlayerID])


class RemoteNarf(Remoted):
    __schema__ = X
    # or, example of a difference between local and remote
    class schema:
        class getRemoteThingy:
            __return__ = Reference(RemoteNarf)
        class movementUpdate:
            posX = int
            posY = int

            # No return value
            __return__ = None

            # Don't wait for the answer
            __wait__ = False

            # Feel free to send this over UDP
            __reliable__ = False

            # but send in order!
            __ordered__ = True

            # use priority queue / stream 3
            __priority__ = 3

            # allow full serialization of failures
            __failure__ = FullFailure

            # default: trivial failures, or str or int
            __failure__ = ErrorMessage

            # These options may imply different method names - e.g. '__wait__ =
            # False' might imply that you can't use callRemote, you have to
            # call 'sendRemote' instead... __reliable__ = False might be
            # 'callRemoteUnreliable' (longer method name to make it less
            # convenient to call by accident...)


## (and yes, donovan, we know that TypedInterface exists and we are going to
## use it.  we're just screwing around with other syntaxes to see what about PB
## might be different.)

Common banana sequences:

A reference to a remote object.
   (On the sending side: Referenceable or ReferenceTo(aRemoteable)
    On the receiving side: RemoteReference)
('remote', reference-id, interface, version, interface, version, ...)


A call to a remote method:
('fastcall', request-id, reference-id,
 method-name, 'arg-name', arg1, 'arg-name', arg2)

A call to a remote method with extra spicy metadata:
('call', request-id, reference-id, interface,
 version, method-name, 'arg-name', arg1, 'arg-name', arg2)

Special hack: request-id of 0 means 'do not answer this call, do not
acknowledge', etc.

Answer to a method call:
('answer', request-id, response)
('error', request-id, response)

Decrement a reference incremented by 'remote' command:
('decref', reference-id)

Broker currently has 9 proto_ methods:

_version(vnum): accept a version number, compare to ours, reject if different

_didNotUnderstand(command): log command, maybe drop connection

_message(reqID, objID, message, answerRequired, netArgs, netKw):
_cachemessage (like _message but finds objID with self.cachedLocallyAs instead
               of self.localObjectForID, used by RemoteCacheMethod and
               RemoteCacheObserver)
 look up objID, invoke it with .remoteMessageReceived(message, args),
 send "answer"(reqID, results)

_answer(reqID, results): look up self.waitingForAnswers[reqID] and fire
                         callback with results

_error(reqID, failure): lookup waitingForAnswers, fire errback

_decref(objID): dec refcount of self.localObjects[objID]. Sent in
                RemoteReference.__del__

_decache(objID): dec refcount of self.remotelyCachedObjects[objID]

_uncache(objID): remove obj from self.locallyCachedObjects[objID]</pre>
</div>
</div>
<div class="section" id="stuff">
<h2>stuff<a class="headerlink" href="#stuff" title="Permalink to this headline">¶</a></h2>
<p>A RemoteReference/RemoteCopy (called a Remote for now) has a schema
attached to it. remote.callRemote(methodname, <a href="#id1"><span class="problematic" id="id2">*</span></a>args) does
schema.getMethodSchema(methodname) to obtain a MethodConstraint that
describes the individual method. This MethodConstraint (or MethodSchema) has
other attributes which are used by either end: what arguments are allowed
and/or expected, calling conventions (synchronous, in-order, priority, etc),
and how the return value should be constrained.</p>
<p>To use the Remote like a RemoteCopy ...</p>
<div class="highlight-python"><pre>Remote:
 .methods
 .attributes
 .getMethodSchema(methodname) -&gt; MethodConstraint
 .getAttributeSchema(attrname) -&gt; a Constraint

XPCOM idl specifies methods and attributes (readonly, readwrite). A Remote
object which represented a distant XPCOM object would have a Schema that is
created by parsing the IDL. Its callRemote would do the appropriate
marshalling. Issue1: XPCOM lets methods have in/out/inout parameters.. these
must be detected and a wrapper generated. Issue2: what about attribute
set/get operations? Could add setRemote and getRemote for these.

---

Some of the schema questions come down to how PBRootSlicer should deal with
instances. The question is whether to treat the instance as a Referenceable
(copy-by-reference: create and transmit a reference number, which will be
turned into a RemoteReference on the other end), or as a Copyable
(copy-by-value: collect some instance state and send it as an instance).
This decision could be made by looking at what the instance inherits from:

  if isinstance(obj, pb.Referenceable):
      sendByReference(obj)
  elif isinstance(obj, pb.Copyable):
      sendByValue(obj)
  else:
      raise InsecureJellyError

or by what it can be adapted to:

  r = IReferenceable(obj, None)
  if r:
      sendByReference(r)
  else:
      r = ICopyable(obj, None)
      if r:
          sendByValue(r)
      else:
          raise InsecureJellyError

The decision could also be influenced by the sending schema currently in
effect. Side A invokes a method on side B. A knows of a schema which states
that the 'foo' argument of this method should be a CopyableSpam, so it
requires the object be adaptable to ICopyableSpam (which is then copied by
value) tries to comply when that argument is serialized. B will enforce its
own schema. When B returns a result to A, the method-result schema on B's
side can influence how the return value is handled.

For bonus points, it may be possible to send the object as a combination of
these two. That may get pretty hard to follow, though.</pre>
</div>
</div>
<div class="section" id="adapters-and-referenceable-copyable">
<h2>adapters and Referenceable/Copyable<a class="headerlink" href="#adapters-and-referenceable-copyable" title="Permalink to this headline">¶</a></h2>
<p>One possibility: rather than using a SlicerRegistry, use Adapters. The
ISliceable interface has one method: getSlicer(). Slicer.py would register
adapters for basic types (list, dict, etc) that would just return an
appropriate ListSlicer, etc. Instances which would have been pb.Copyable
subclasses in oldpb can still inherit from pb.Copyable, which now implements
ISliceable and produces a Slicer (opentype=&#8217;instance&#8217;) that calls
getStateToCopy() (although the subclass-__implements__ handling is now more
important than before). pb.Referenceable implements ISlicer and produces a
Slicer (opentype=&#8217;reference&#8217;?) which (possibly) registers itself in the
broker and then sends the reference number (along with a schema if necessary
(and the other end wants them)).</p>
<p>Classes are also welcome to implement ISlicer themselves and produce
whatever clever (streaming?) Slicer objects they like.</p>
<p>On the receiving side, we still need a registry to provide reasonable
security. There are two registries. The first is the
RootUnslicer.openRegistry, and maps OPEN types to Unslicer factories. It is
used in doOpen().</p>
<p>The second registry should map opentype=instance class names to something
which can handle the instance contents. Should this be a replacement
Unslicer?</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Foolscap Schemas</a><ul>
<li><a class="reference internal" href="#existing-constraint-classes">Existing <tt class="docutils literal"><span class="pre">Constraint</span></tt>  classes</a></li>
<li><a class="reference internal" href="#stuff">stuff</a></li>
<li><a class="reference internal" href="#adapters-and-referenceable-copyable">adapters and Referenceable/Copyable</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="logging.html"
                        title="previous chapter">Foolscap Logging</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="serializing.html"
                        title="next chapter">Using Foolscap for Serialization</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/schema.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="serializing.html" title="Using Foolscap for Serialization"
             >next</a> |</li>
        <li class="right" >
          <a href="logging.html" title="Foolscap Logging"
             >previous</a> |</li>
        <li><a href="index.html">Foolscap v0.6.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Brian Warner.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>