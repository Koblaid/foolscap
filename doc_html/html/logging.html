

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Foolscap Logging &mdash; Foolscap v0.6.1 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.6.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Foolscap v0.6.1 documentation" href="index.html" />
    <link rel="next" title="Foolscap Schemas" href="schema.html" />
    <link rel="prev" title="Flappserver: The Foolscap Application Server" href="flappserver.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="schema.html" title="Foolscap Schemas"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="flappserver.html" title="Flappserver: The Foolscap Application Server"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Foolscap v0.6.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="foolscap-logging">
<h1>Foolscap Logging<a class="headerlink" href="#foolscap-logging" title="Permalink to this headline">¶</a></h1>
<p>Foolscap comes with an advanced event-logging package. This package is
used internally to record connection establishment, remote message delivery,
and errors. It can also be used by applications built on top of Foolscap for
their own needs.</p>
<p>This logging package includes a viewer application that processes locally
saved log data or data retrieved over a foolscap connection, and displays a
selected subset of the events. It also includes code to create a web page
inside your application that presents the same kind of log view.</p>
<div class="section" id="philosophy">
<h2>Philosophy<a class="headerlink" href="#philosophy" title="Permalink to this headline">¶</a></h2>
<p>My background is in embedded systems, specifically routers, in which bugs
and unexpected operations happen from time to time, causing problems. In this
environment, storage space is at a premium (most routers do not have hard
drives, and only a limited amount of RAM and non-volatile flash memory), and
devices are often deployed at remote sites with no operator at the console.
Embedded devices are expected to function properly without human
intervention, and crashes or other malfunctions are rare compared to
interactive applications.</p>
<p>In this environment, when an error occurs, it is a good idea to record as
much information as possible, because asking the operator to turn on extra
event logging and then try to re-create the failure is only going to make the
customer more angry (&#8220;my network has already broken once today, you want me
to intentionally break it again?&#8221;). That one crash is the only chance you
have to learn about the cause.</p>
<p>In addition, as new features are being developed (or completed ones are
being debugged), it is important to have visibility into certain internal
state. Extra logging messages are added to illuminate this state, sometimes
resulting in hundreds of messages per second. These messages are useful only
while the problem is being investigated. Since most log formats involve flat
text files, lots of additional log messages tend to obscure important things
like unhandled exceptions and assertion failures, so once the messages have
outlived their usefulness they are just getting in the way. Each message
costs a certain amount of human attention, so we are motiviated to minimize
that cost by removing the unhelpful messages.</p>
<p>Logging also gets removed because it consumes CPU time, disk IO, disk
space, or memory space. Many operations that can be done in linear time can
expand to super-linear time if additional work is required to log the actions
taking place, or the current state of the program.</p>
<p>As a result, many formerly-useful log messages are commented out once they
have served their purpose. Having been disabled, the cost to re-enable them
if the bug should resurface is fairly high: at the very least it requires
modifying the source code and restarting the program, and for some languages
requires a complete recompile/rebuild. Even worse, to keep the source code
readable, disabled log messages are frequently deleted altogether. After many
months it may not be obvious where the log messages should be put back, and
developers will need to re-acquaint themselves with the code base to find
suitable places for those messages.</p>
<p>To balance these costs, developers try to leave enough log messages in
place that unexpected events will be captured with enough detail to start
debugging, but not so many that it impacts performance or a human&#8217;s ability
to spot problems while scanning the logs. But it would be nice if certain log
messages could be disabled or disregarded in a way that didn&#8217;t abandon all of
the work that went into developing and placing them.</p>
<div class="section" id="memory-limited-strangeness-triggered-log-dumping">
<h3>Memory-limited, strangeness-triggered log dumping<a class="headerlink" href="#memory-limited-strangeness-triggered-log-dumping" title="Permalink to this headline">¶</a></h3>
<p>Each potential log message could be described (to a human) as being useful
in a particular set of circumstances. For example, if the program tried to
read from a file and got a permission-denied error, it would be useful to
know which file it was trying to read from, and how it came to decide upon
that particular filename, and what user command was responsible for
triggering this action. If a protocol parser which implements a state machine
finds itself in an invalid state, it would be useful to know what series of
input messages had arrived recently, to work backwards to the place where
things started to go awry.</p>
<p>Flip this around and you can phrase it as: the filename we compute will be
interesting only if we get an error when we finally try to access it.
Likewise, the series of input messages <strong>would</strong> be interesting to know
if, at some point in the near future, an invalid protocol state is
reached.</p>
<p>The thing to note about these patterns is that an event at time T**causes** events before time T to become interesting. Interesting
messages are worth keeping (and storing, and examining). Non-interesting
messages are not worth as much, but there are different kinds of costs, and
as the message becomes less interesting (or loses the potential to become
interesting), we want to lower our costs. Displaying a message to a human is
pretty expensive, since it tends to obscure other, more important messages.
Storing messages is less expensive, depending upon how long we expect to
store them (and how much storage space is available). Generating messages may
be expensive or cheap, depending upon their frequency and complexity.</p>
<p>Foolscap&#8217;s logging library seeks to capture this ex-post-facto
interestingness by categorizing messages into &#8220;severity levels&#8221;, recording
each level into a separate size-limited circular buffer, and provoking a dump
of all buffers when an &#8220;Incident&#8221; occurs. An &#8220;Incident Qualifier&#8221; is used to
classify certain higher-severity events as worthy of triggering the log dump.
The idea is that, at any given time, we have a record (in memory) of a lot of
low-frequency important things (like program startup, user actions, and
unhandled exceptions), and only the most recent high-frequency events
(verbose debugging data). But, if something strange happens, we dump
everything we&#8217;ve got to disk, because it is likely that some of these noisy
high-frequency not-normally-interesting events will be helpful to track down
the cause of the unusual event. The viewing tools then rearrange all of these
events into a linear order, and make it easy to filter out events by severity
level or origin.</p>
<p>Each severity level is (roughly) inversely proportional to a message rate.
Assertion checks in code are in the &#8220;this should never happen&#8221; category, and
their resulting low expected rate puts them in a high-severity level. Routine
actions are expected to happen all the time, which puts them into a
low-severity level.</p>
<p>(you might think of severity as a separate axis than frequency. Severity
would mean &#8220;how much damage will this cause&#8221;. Frequency equals cost,
controlling how long we keep the message around in the hopes of it becoming
interesting. But things which cause a lot of damage should not be happening
very frequently, and things which happen frequently must not cause a lot of
damage. So these axes are sufficiently aligned for us to use just a single
parameter for now.)</p>
</div>
<div class="section" id="structured-logging">
<h3>Structured Logging<a class="headerlink" href="#structured-logging" title="Permalink to this headline">¶</a></h3>
<p>The usual approach to event logging involves a single file with a sequence
of lines of text, new events being continually appended at the end, perhaps
with the files being rotated once they become too large or old. Typically the
source code is peppered with lines like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">log</span><span class="o">.</span><span class="n">msg</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="n">Log</span><span class="o">.</span><span class="n">Log</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">facility</span><span class="p">,</span> <span class="n">severity</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">log_stacktrace</span><span class="p">()</span>
<span class="n">log</span><span class="o">.</span><span class="n">err</span><span class="p">(</span><span class="n">failure</span><span class="p">)</span>
</pre></div>
</div>
<p>Each such function call adds some more text to the logfile, encoding the
various parameters into a new line.</p>
<p>Using a text-based file format enables the use of certain unix tools like
&#8216;grep&#8217; and &#8216;wc&#8217; to analyze the log entries, but frequently inhbits the use of
more complex tools because they must first parse the human-readable lines
back into the structured arguments that were originally passed to the log()
call. Frequently, the free-form text portion of the log cannot be reliably
distinguished from the stringified metadata (the quoting issue), making
analysis tools more difficult to write. In addition, the desire to make both
logfiles and the generating source code more greppable is occasionally at
odds with clean code structure (putting everything on a single line) or
refactoring goals (sending all logging for a given module through a common
function).</p>
<p>The Foolscap log system uses binary logfiles that accurately and
reversibly serialize all the metadata associated with a given event. Tools
are provided to turn this data into a human-readable greppable form, but
better tools are provided to perform many of the same tasks that &#8216;grep&#8217; is
typically used for. For example, a log viewer can apply a python expression
to each event as a filter, and the expression can do arbitrary comparison of
event parameters (e.g. &#8220;show me all events related to failing uploads of
files larger than 20MB&#8221;).</p>
<p>To accomplish this, all unrecognized keyword arguments to the``log.msg`` call are recorded as additional keys in the log event.
To encourage structured usage, the message string be provided as a format
specifier instead of a pre-interpolated string, using the keyword args as a
formatting dictionary. Any time the string is displayed to a human, the
keyword args are interpolated into the format string first.</p>
<p>(in compiled languages, it would be useful and cheap to embed the source
file and line number of the log() call inside the log event. Unfortunately,
in Python, this would require expensive stack crawling, so developers are
generally stuck with grepping for the log message in their source tree to
backtrack from a log message to the code that generated it)</p>
</div>
<div class="section" id="remote-log-aggregation">
<h3>Remote log aggregation<a class="headerlink" href="#remote-log-aggregation" title="Permalink to this headline">¶</a></h3>
<p>Code is provided to allow a Foolscap-based application to easily publish a
&#8216;logport&#8217;: an object which providers remote callers with access to that
application&#8217;s accumulated log data. Events are delivered over a secure
Foolscap connection, to prevent eavesdroppers from seeing sensitive data
inside the log messages themselves. This can be useful for a developer who
wants to find out what just happened inside a given application, or who is
about to do something to the application and wants to see how it responds
from the inside. The <tt class="docutils literal"><span class="pre">flogtool</span> <span class="pre">tail</span></tt> tool is provided for this
job.</p>
<p>Each Tub always activates a logport, and a Tub option makes it possible to
use a persistent FURL for remote access.</p>
<p>(TODO: really?) The log-viewer application can either read log data from a
local log directory, or it can connect to the logport on a remote host.</p>
<p>A centralized &#8220;log gatherer&#8221; program can connect to multiple logports and
aggregate all the logs collected from each, similar to the unix &#8216;syslog&#8217;
facility. This is most useful when the gatherer is configured to store more
messages than the applications (perhaps it stores all of them), since it
allows the costs to be shifted to a secondary machine with extra disk and
fewer CPU-intensive responsibilities.</p>
<p>To facilitate this, each Tub can either be given the FURL of a Log
Gatherer, or the name of a file that might contain this FURL. This makes
deployment easier: just copy the FURL of your central gatherer into this file
in each of your application&#8217;s working directories.</p>
<p>A basic log gatherer is created by running <tt class="docutils literal"><span class="pre">flogtool</span> <span class="pre">create-gatherer</span></tt> and giving it a storage directory: this emits a
gatherer FURL that can be used in the app configuration, and saves all
incoming log events to disk.</p>
</div>
<div class="section" id="causality-tracing">
<h3>Causality Tracing<a class="headerlink" href="#causality-tracing" title="Permalink to this headline">¶</a></h3>
<p>Log messages correspond to events. Events are triggered by other events.
Sometimes the relationship between events is visible to the local programmer,
sometimes it involves external hosts that can confuse the relationships.</p>
<p>For local &#8220;application-level&#8221; causality, Foolscap&#8217;s logging system makes
it possible to define hierarchies of log events. Each call to``log.msg`` returns an identifier (really just a number). If you
pass this same identifier into a later <tt class="docutils literal"><span class="pre">log.msg</span></tt> call as the``parent=`` parameter, that second message is said to be a &#8220;child&#8221;
of the first. This creates multiple trees of log events, in which the tree
tops are the parentless messages. For example, a user command like &#8220;copy this
file&#8221; could be a top-level event, while the various steps involved in copying
the file (compute source filename, open source file, compute target filename,
open target file, read data, write data, close) would be children of that
top-level event.</p>
<p>The viewer application has a way to hide or expand the nodes of these
trees, to make it easy to look at just the messages that are related to a
specific action. This lets you prioritize events along both severity (is this
a common event?) and relevance (is this event related to the one of
interest?)</p>
<p>In the future, Foolscap&#8217;s logging system will be enhanced to offer tools
for analyzing causality relationships between multiple systems, taking
inspiration from the E <a class="reference external" href="http://www.erights.org/elang/tools/causeway/index.html">Causeway</a>
debugger. In this system, when one Tub sends a message to another, enough
data is logged to enable a third party (with access to all the logs) to
figure out the set of operations that were <strong>caused</strong> by the first
message. Each message send is recorded, with an index that includes the
TubID, current event number, and stack trace. Event A on tub 1 triggers event
B on tub 2, along with certain operations and log messages. Event B triggers
further operations, etc.</p>
<p>The viewer application will offer a causality-oriented view in addition to
the temporal one.</p>
</div>
</div>
<div class="section" id="using-foolscap-logging">
<h2>Using Foolscap Logging<a class="headerlink" href="#using-foolscap-logging" title="Permalink to this headline">¶</a></h2>
<p>The majority of your application&#8217;s interaction with the Foolscap logging
system will be in the form of calls to its <tt class="docutils literal"><span class="pre">log.msg</span></tt> function.</p>
<div class="section" id="logging-messages-from-application-code">
<h3>Logging Messages From Application Code<a class="headerlink" href="#logging-messages-from-application-code" title="Permalink to this headline">¶</a></h3>
<p>To emit log messages from application code, just use the``foolscap.log.msg`` function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">foolscap.logging</span> <span class="kn">import</span> <span class="n">log</span>

<span class="n">log</span><span class="o">.</span><span class="n">msg</span><span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>You can add arguments that will be lazily evaluated and stringified by
treating the log message as a normal format string:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">log</span><span class="o">.</span><span class="n">msg</span><span class="p">(</span><span class="s">&quot;queue depth </span><span class="si">%d</span><span class="s"> exceeds limit </span><span class="si">%d</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current_depth</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
</pre></div>
</div>
<p>Or you can use keyword arguments instead. The format string can use
positional parameters, or keyword arguments, but not both.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">log</span><span class="o">.</span><span class="n">msg</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="s">&quot;Danger </span><span class="si">%(name)s</span><span class="s"> </span><span class="si">%(surname)s</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;Will&quot;</span><span class="p">,</span> <span class="n">surname</span><span class="o">=</span><span class="s">&quot;Robinson&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Passing arguments as separate parameters (instead of interpolating them
before calling <tt class="docutils literal"><span class="pre">log.msg</span></tt> has the benefit of preserving more
information: later, when you view the log messages, you can apply python
filter expressions that use these parameters as search criteria.</p>
<p>Regardless of how you format the main log message, you can always pass
additional keyword arguments, and their values will be serialized into the
log event. This will not be automatically stringified into a printed form of
the message, but it will be available to other tools (either to filter upon
or to display):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">log</span><span class="o">.</span><span class="n">msg</span><span class="p">(</span><span class="s">&quot;state changed&quot;</span><span class="p">,</span> <span class="n">previous</span><span class="o">=</span><span class="n">states</span><span class="p">[</span><span class="n">now</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">current</span><span class="o">=</span><span class="n">stats</span><span class="p">[</span><span class="n">now</span><span class="p">])</span>
</pre></div>
</div>
<div class="section" id="modifying-log-messages">
<h4>Modifying Log Messages<a class="headerlink" href="#modifying-log-messages" title="Permalink to this headline">¶</a></h4>
<p>There are a number of arguments you can add to the <tt class="docutils literal"><span class="pre">log.msg</span></tt>
call that foolscap will treat specially:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">parent</span> <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="n">msg</span><span class="p">(</span><span class="n">facility</span><span class="o">=</span><span class="s">&quot;app.initialization&quot;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">log</span><span class="o">.</span><span class="n">INFREQUENT</span><span class="p">,</span>
                 <span class="n">msg</span><span class="o">=</span><span class="s">&quot;hello world&quot;</span><span class="p">,</span> <span class="n">stacktrace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">msg</span><span class="p">(</span><span class="n">facility</span><span class="o">=</span><span class="s">&quot;app.storage&quot;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">log</span><span class="o">.</span><span class="n">OPERATIONAL</span><span class="p">,</span>
        <span class="n">msg</span><span class="o">=</span><span class="s">&quot;init storage&quot;</span><span class="p">,</span> <span class="n">stacktrace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">level</span></tt> argument is how you specify a severity level, and
takes a constant from the list defined in <tt class="docutils literal"><span class="pre">foolscap/log.py</span></tt> :</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">BAD</span></tt> : something which significantly breaks functionality.
Unhandled exceptions and broken invariants fall into this category.</li>
<li><tt class="docutils literal"><span class="pre">SCARY</span></tt> : something which is a problem, and shouldn&#8217;t happen
in normal operation, but which causes minimal functional impact, or from
which the application can somehow recover.</li>
<li><tt class="docutils literal"><span class="pre">WEIRD</span></tt> : not as much of a problem as SCARY, but still not
right.</li>
<li><tt class="docutils literal"><span class="pre">CURIOUS</span></tt></li>
<li><tt class="docutils literal"><span class="pre">INFREQUENT</span></tt> : messages which are emitted as a normal course
of operation, but which happen infrequently, perhaps once every ten to one
hundred seconds. User actions like triggering an upload or sending a
message fall into this category.</li>
<li><tt class="docutils literal"><span class="pre">UNUSUAL</span></tt> : messages which indicate events that are not
normal, but not particularly fatal. Examples include excessive memory or
CPU usage, minor errors which can be corrected by fallback code.</li>
<li><tt class="docutils literal"><span class="pre">OPERATIONAL</span></tt> : messages which are emitted as a normal course
of operation, like all the steps involved in uploading a file, potentially
one to ten per second..</li>
<li><tt class="docutils literal"><span class="pre">NOISY</span></tt> : verbose debugging about small operations,
potentially emitting tens or hundreds per second</li>
</ul>
<p>The <tt class="docutils literal"><span class="pre">stacktrace</span></tt> argument controls whether or not a stack trace
is recorded along with the rest of the log message.</p>
<p>The <tt class="docutils literal"><span class="pre">parent</span></tt> argument allows messages to be related to earlier
messages.</p>
</div>
<div class="section" id="logging-messages-through-a-tub">
<h4>Logging Messages Through a Tub<a class="headerlink" href="#logging-messages-through-a-tub" title="Permalink to this headline">¶</a></h4>
<p>Each Tub offers a log method: this is just like the process-wide``log.msg`` described above, but it adds an additional parameter
named <tt class="docutils literal"><span class="pre">tubid</span></tt> . This is convenient during analysis, to identify
which messages came from which applications.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Example</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tub</span> <span class="o">=</span> <span class="n">Tub</span><span class="p">()</span>
    <span class="o">...</span>
  <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tub</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s">&quot;about to send query to server&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">server</span><span class="o">.</span><span class="n">callRemote</span><span class="p">(</span><span class="s">&quot;query&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">addCallback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_query_done</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="facilities">
<h3>Facilities<a class="headerlink" href="#facilities" title="Permalink to this headline">¶</a></h3>
<p>Facility names are up to the application: the viewer app will show a list
of checkboxes, one for each facility name discovered in the logged data.
Facility names should be divided along functional boundaries, so that
developers who do not care about, say, UI events can turn all of them off
with a single click. Related facilities can be given names separated with
dots, for example &#8220;ui.internationalization&#8221; and &#8220;ui.toolkit&#8221;, and the
viewer app may make it easy to enable or disable entire groups at once.
Facilities can also be associated with more descriptive strings by calling``log.explain_facility`` at least once:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">log</span><span class="o">.</span><span class="n">explain_facility</span><span class="p">(</span><span class="s">&quot;ui.web&quot;</span><span class="p">,</span> <span class="s">&quot;rendering pages for the web UI&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="that-was-weird-buttons">
<h3>&#8220;That Was Weird&#8221; Buttons<a class="headerlink" href="#that-was-weird-buttons" title="Permalink to this headline">¶</a></h3>
<p>Sometimes it is the user of your application who is in the best position
to decide that something weird has taken place. Internal consistency checks
are useful, but the user is the final judge of what meets their needs. So if
they were expecting one thing to happen and something else happened instead,
they should be able to declare that an Incident has taken place, perhaps by
pushing a special &#8220;That Was Weird&#8221; button in your UI.</p>
<p>To implement this sort of button for your user, just take the user&#8217;s
reason string and log it in an event at level WEIRD or higher. Since events
at this level trigger Incidents by default, Foolscap&#8217;s normal
incident-handling behavior will take care of the rest for you.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">that_was_weird_button_pushed</span><span class="p">(</span><span class="n">reason</span><span class="p">):</span>
    <span class="n">log</span><span class="o">.</span><span class="n">msg</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="s">&quot;The user said that was weird: </span><span class="si">%(reason)s</span><span class="s">&quot;</span><span class="p">,</span>
            <span class="n">reason</span><span class="o">=</span><span class="n">reason</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="n">log</span><span class="o">.</span><span class="n">WEIRD</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="configuring-logging">
<h2>Configuring Logging<a class="headerlink" href="#configuring-logging" title="Permalink to this headline">¶</a></h2>
<p>Foolscap&#8217;s logging system is always enabled, but the unconfigured initial
state is lacking a number of useful features. By configuring the logging
system at application startup, you can enable these features.</p>
<div class="section" id="saving-log-events-to-disk">
<h3>Saving Log Events to Disk<a class="headerlink" href="#saving-log-events-to-disk" title="Permalink to this headline">¶</a></h3>
<p>The first missing piece is that it does not have a place to save log
events in the event of something strange happening, so the short-term
circular buffers are the only source of historical log events.</p>
<p>To give the logging system some disk space to work with, just give it a
logdir. The logging system will dump the circular buffers into this directory
any time something strange happens, and both the in-memory buffers and the
on-disk records are made available to viewing applications:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">foolscap.logging</span> <span class="kn">import</span> <span class="n">log</span>
<span class="n">log</span><span class="o">.</span><span class="n">setLogDir</span><span class="p">(</span><span class="s">&quot;~/saved-log-events&quot;</span><span class="p">)</span>   <span class="c"># == log.theLogger.setLogDir</span>
</pre></div>
</div>
<p>The foolscap logging code does not delete files from this directory.
Applications which set up a logdir should arrange to delete old files once
storage space becomes a problem. TODO: we could provide a maximum size for
the logdir and have Foolscap automatically delete the oldest logfiles to stay
under the size limit: this would make the disk-based logdir an extension of
the memory-based circular buffers.</p>
<div class="section" id="incidents">
<h4>Incidents<a class="headerlink" href="#incidents" title="Permalink to this headline">¶</a></h4>
<p>Foolscap&#8217;s logging subsystem uses the term &#8220;Incident&#8221; to describe the
&#8220;something strange&#8221; that causes the buffered log events to be dumped. The
logger has an &#8220;Incident Qualifier&#8221; that controls what counts as an incident.
The default qualifier simply fires on events at severity level``log.WEIRD`` or higher. You can override the qualifier by
subclassing <tt class="docutils literal"><span class="pre">foolscap.logging.incident.IncidentQualifier</span></tt> and
calling <tt class="docutils literal"><span class="pre">log.setIncidentQualifier</span></tt> with an instance of your new
class. For example, certain facilities might be more important than others,
and you might want to declare an Incident for unusual but relatively
low-severity events in those facilities:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">foolscap.logging</span> <span class="kn">import</span> <span class="n">log</span><span class="p">,</span> <span class="n">incident</span>

<span class="k">class</span> <span class="nc">BetterQualifier</span><span class="p">(</span><span class="n">incident</span><span class="o">.</span><span class="n">IncidentQualifier</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">check_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ev</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ev</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;facility&#39;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;lifesupport&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ev</span><span class="p">[</span><span class="s">&#39;level&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">UNUSUAL</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="n">incident</span><span class="o">.</span><span class="n">IncidentQualifier</span><span class="o">.</span><span class="n">check_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ev</span><span class="p">)</span>

<span class="n">log</span><span class="o">.</span><span class="n">setIncidentQualifier</span><span class="p">(</span><span class="n">BetterQualifier</span><span class="p">())</span>
</pre></div>
</div>
<p>The qualifier could also keep track of how many events of a given type had
occurred, and trigger an incident if too many UNUSUAL events happen in rapid
succession, or if too many recoverable errors are observed within a single
operation.</p>
<p>Once the Incident has been declared, the &#8220;Incident Reporter&#8221; is
responsible for recording the recent events to the file on disk. The default
reporter copies everything from the circular buffers into the logfiles, then
waits an additional 5 seconds or 100 events (whichever comes first),
recording any trailing events into the logfile too. The idea is to capture
the application&#8217;s error-recovery behavior: if the application experiences a
problem, it should log something at the <tt class="docutils literal"><span class="pre">log.WEIRD</span></tt> level (or
similar), then attempt to fix the problem. The post-trigger trailing event
logging code should capture the otherwise-ordinary events performed by this
recovery code.</p>
<p>Overlapping incidents will be combined: if an incident reporter is already
active when the qualifier sees a new triggering event, that event is just
added to the existing reporter.</p>
<p>The incident reporter can be overridden as well, by calling``log.setIncidentReporterFactory`` with a <strong>class</strong> that will
produce reporter instances. For example, if you wanted to increase the
post-trigger event recording to 1000 events or 10 seconds, then you could do
something like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">foolscap.logging</span> <span class="kn">import</span> <span class="n">log</span><span class="p">,</span> <span class="n">incident</span>

<span class="k">class</span> <span class="nc">MoreRecoveryIncidentReporter</span><span class="p">(</span><span class="n">incident</span><span class="o">.</span><span class="n">IncidentReporter</span><span class="p">):</span>
    <span class="n">TRAILING_DELAY</span> <span class="o">=</span> <span class="mf">10.0</span>
    <span class="n">TRAILING_EVENT_LIMIT</span> <span class="o">=</span> <span class="mi">1000</span>

<span class="n">log</span><span class="o">.</span><span class="n">setIncidentReporterFactory</span><span class="p">(</span><span class="n">MoreRecoveryIncidentReporter</span><span class="p">)</span>
</pre></div>
</div>
<p>Recorded Incidents will be saved in the logdir with filenames like``incident-2008-05-02&#8211;01-12-35Z-w2qn32q.flog.bz2`` , containing both
a (UTC) timestamp and a random/unique suffix. These can be read with tools
like <tt class="docutils literal"><span class="pre">flogtool</span> <span class="pre">dump</span></tt> and <tt class="docutils literal"><span class="pre">flogtool</span> <span class="pre">web-viewer</span></tt> .</p>
</div>
</div>
<div class="section" id="setting-up-the-logport">
<h3>Setting up the logport<a class="headerlink" href="#setting-up-the-logport" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">logport</span></tt> is a <tt class="docutils literal"><span class="pre">foolscap.Referenceable</span></tt> object
which provides access to all available log events. Viewer applications can
either retrieve old events (buffered in RAM or on disk), or subscribe to hear
about new events that occur later. The logport implements the``foolscap.logging.interfaces.RILogPublisher`` interface, which
defines the methods that can be called on it. Each Tub automatically creates
and registers a logport: the <tt class="docutils literal"><span class="pre">tub.getLogPort()</span></tt> and``tub.getLogPortFURL()`` methods make it possible to grant access to
others:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t</span> <span class="o">=</span> <span class="n">Tub</span><span class="p">()</span>
<span class="o">...</span> <span class="c"># usual Tub setup: startService, listenOn, setLocation</span>

<span class="n">logport_furl</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">getLogPortFURL</span><span class="p">()</span> <span class="c"># this is how you learn the logport furl</span>
<span class="k">print</span> <span class="s">&quot;please point your log viewer at: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">logport_furl</span>

<span class="n">logport</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">getLogPort</span><span class="p">()</span> <span class="c"># a Referenceable you can pass over the wire</span>
<span class="n">rref</span><span class="o">.</span><span class="n">callRemote</span><span class="p">(</span><span class="s">&quot;please_use_my_logport&quot;</span><span class="p">,</span> <span class="n">logport</span><span class="p">)</span>
</pre></div>
</div>
<p>The default behavior is register the logport object with an ephemeral
name, and therefore its FURL will change from one run of the program to the
next. This can be an operational nuisance, since the external log viewing
program you&#8217;re running (<tt class="docutils literal"><span class="pre">flogtool</span> <span class="pre">tail</span> <span class="pre">LOGPORT</span></tt> ) would need a new
FURL each time the target program is restarted. By giving the logport a place
to store its FURL between program runs, the logport gets a persistent name.
The <tt class="docutils literal"><span class="pre">logport-furlfile</span></tt> option is used to identify this file. If
the file exists, the desired FURL will be read out of it. If it does not, the
newly-generated FURL will be written into it.</p>
<p>If you use <tt class="docutils literal"><span class="pre">logport-furlfile</span></tt> , it must be set before you call``getLogPortFURL`` (and also before you pass the result of``getLogPort`` over the wire), otherwise an ephemeral name will have
already been registered and the persistent one will be ignored. The call to``setOption`` can take place before <tt class="docutils literal"><span class="pre">setLocation</span></tt> , and
the logport-furlfile will be created as soon as both the filename and the
location hints are known. However, note that the logport will not be
available until after <tt class="docutils literal"><span class="pre">setLocation</span></tt> is called:<tt class="docutils literal"><span class="pre">getLogPortFURL</span></tt> and <tt class="docutils literal"><span class="pre">getLogPort</span></tt> will raise
exceptions.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tub</span><span class="o">.</span><span class="n">setOption</span><span class="p">(</span><span class="s">&quot;logport-furlfile&quot;</span><span class="p">,</span> <span class="s">&quot;~/logport.furl&quot;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;please point your log viewer at: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">tub</span><span class="o">.</span><span class="n">getLogPortFURL</span><span class="p">()</span>
</pre></div>
</div>
<p>This <tt class="docutils literal"><span class="pre">logport.furl</span></tt> file can be read directly by other tools if
you want to point them at an operating directory rather than the actual
logport FURL. For example, the <tt class="docutils literal"><span class="pre">flogtool</span> <span class="pre">tail</span></tt> command (described
below) can accept either an actual FURL, or the directory in which a file
named <tt class="docutils literal"><span class="pre">logport.furl</span></tt> can be located, making it easier to examine
the logs of a local application. Note that the <tt class="docutils literal"><span class="pre">logport-furlfile</span></tt>
is chmod&#8217;ed <tt class="docutils literal"><span class="pre">go-r</span></tt> , since it is a secret: the idea is that only
people with access to the application&#8217;s working directory (and presumeably to
the application itself) should get access to the logs.</p>
</div>
<div class="section" id="configuring-a-log-gatherer">
<h3>Configuring a Log Gatherer<a class="headerlink" href="#configuring-a-log-gatherer" title="Permalink to this headline">¶</a></h3>
<p>The third feature that requires special setup is the log gatherer. You can
either tell the Tub a specific gatherer to use, or give it a filename where
the FURL of a log gatherer is stored.</p>
<p>The <tt class="docutils literal"><span class="pre">tub.setOption(&quot;log-gatherer-furl&quot;,</span> <span class="pre">gatherer_FURL)</span></tt> call
can be used to have the Tub automatically connect to the log gatherer and
offer its logport. The Tub uses a Reconnector to make sure the gatherer
connection is reestablished each time it gets dropped.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t</span> <span class="o">=</span> <span class="n">Tub</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">setOption</span><span class="p">(</span><span class="s">&quot;log-gatherer-furl&quot;</span><span class="p">,</span> <span class="n">gatherer_FURL</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, you can use the``tub.setOption(&#8220;log-gatherer-furlfile&#8221;, &#8220;~/gatherer.furl&#8221;)`` call
to tell the Tub about a file where a gatherer FURL might be found. If that
file exists, the Tub will read a FURL from it, otherwise the Tub will not use
a gatherer. The file can contain multiple log-gatherer FURLs, one per line.
This is probably the easiest deployment mode:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t</span> <span class="o">=</span> <span class="n">Tub</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">setOption</span><span class="p">(</span><span class="s">&quot;log-gatherer-furlfile&quot;</span><span class="p">,</span> <span class="s">&quot;~/gatherer.furl&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>In both cases, the gatherer FURL is expected to point to a remote object
which implements the <tt class="docutils literal"><span class="pre">foolscap.logging.RILogGatherer</span></tt> interface
(such as the service created by <tt class="docutils literal"><span class="pre">flogtool</span> <span class="pre">create-gatherer</span></tt> ). The
Tub will connect to the gatherer and offer it the logport.</p>
<p>The <tt class="docutils literal"><span class="pre">log-gatherer-furl</span></tt> and <tt class="docutils literal"><span class="pre">log-gatherer-furlfile</span></tt>
options can be set at any time, however the connection to the gatherer will
not be initiated until <tt class="docutils literal"><span class="pre">setLocation</span></tt> is called.</p>
</div>
<div class="section" id="interacting-with-other-logging-systems">
<h3>Interacting With Other Logging Systems<a class="headerlink" href="#interacting-with-other-logging-systems" title="Permalink to this headline">¶</a></h3>
<p>There are two other logging systems that the Foolscap logging code knows
how to handle: <tt class="docutils literal"><span class="pre">twisted.python.log</span></tt> and the stdlib``logging`` system.</p>
<p>First, a brief discussion of the single-instance nature of Foolscap&#8217;s
logging is in order. Each process that uses Foolscap gets a single instance
of the Foolscap logging code (named <tt class="docutils literal"><span class="pre">theLogger</span></tt> and defined at
module level in <tt class="docutils literal"><span class="pre">foolscap.logging.log</span></tt> ). This maintains a single
logdir. Each time a process is started it gets a new &#8220;incarnation record&#8221;,
which consists of a randomly generated (unique) number, and (if a logdir is
available) (TODO) a continuously incrementing sequence number. All log events
are tagged with this incarnation record: it is used to distinguish between
event#23 in one process versus the same event number from a different
process.</p>
<p>Each Tub has a distinct TubID, and all log events that go through the Tub
(via <tt class="docutils literal"><span class="pre">tub.log</span></tt> ) are tagged with this TubID. Each Tub maintains its
own logport (specifically there is a single <tt class="docutils literal"><span class="pre">LogPublisher</span></tt> object,
but like all Referenceables it can be registered in multiple Tubs and gets a
distinct FURL for each one).</p>
<div class="section" id="twisted-python-log">
<h4>twisted.python.log<a class="headerlink" href="#twisted-python-log" title="Permalink to this headline">¶</a></h4>
<p>Twisted&#8217;s logging mechanism is used by importing``twisted.python.log`` and invoking its <tt class="docutils literal"><span class="pre">log.msg()</span></tt> and``log.err`` methods. This mechanism is used extensively by Twisted
itself; the most important messages are those concerning &#8220;Unhandled Error in
Deferred&#8221; and other exceptions in processing received data and timed calls.
The normal destination for Twisted log messages depends upon how the
application is run: the <tt class="docutils literal"><span class="pre">twistd</span></tt> daemonization tool sends the log
messages to a file named <tt class="docutils literal"><span class="pre">twistd.log</span></tt> , the <tt class="docutils literal"><span class="pre">trial</span></tt>
unit-test tool puts them in <tt class="docutils literal"><span class="pre">_trial_temp/test.log</span></tt> , and standalone
scripts discard these logs by default (unless you use something like``log.startLogging(sys.stderr)`` ).</p>
<p>To capture these log messages, you need a &#8220;bridge&#8221;, which will add a
Twisted log observer and copy each Twisted log message into Foolscap. There
can be at most one such bridge per python process. Either you will use a
generic bridge (which tags each message with the incarnation record), or you
will use a Tub as a bridge (which additionally tags each message with the
TubID). Each time you set the twisted log bridge, any previous bridge is
discarded.</p>
<p>When you have only one Tub in an application, use the Tub bridge. Likewise
if you have multiple Tubs but there is one that is long-lived, use that Tub
for the bridge. If you have mutiple Tubs with no real primary one, use the
generic bridge. Using a Tub bridge adds slightly more information to the log
events, and may make it a bit easier to correlate Twisted log messages with
actions of your application code, especially when you&#8217;re combining events
from several applications together for analysis.</p>
<p>To set up the generic bridge, use the following code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">foolcap.logging</span> <span class="kn">import</span> <span class="n">log</span>
<span class="n">log</span><span class="o">.</span><span class="n">bridgeTwistedLogs</span><span class="p">()</span>
</pre></div>
</div>
<p>To set up a Tub bridge, use this instead:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t</span> <span class="o">=</span> <span class="n">Tub</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">setOption</span><span class="p">(</span><span class="s">&quot;bridge-twisted-logs&quot;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that for Tub bridges, the Twisted log messages will only be delivered
while the Tub is running (specifically from the time its startService()
method is until its stopService() method is called). TODO: review this
behavior, we want earlier messages to be bridged too.</p>
<p>To bridge log events in the other direction (i.e. taking foolscap log
messages and copying them into twisted), use the``log.bridgeLogsToTwisted()`` call, or the``FLOGTOTWISTED`` environment variable. This is useful to get
foolscap.logging.log.msg() events copied into <tt class="docutils literal"><span class="pre">twistd.log</span></tt> . The
default filter only bridges non-noisy events (i.e. those at level OPERATIONAL
or higher), and does not bridge foolscal internal events.</p>
<p>You might use this if you don&#8217;t buy into the foolscap logging philosophy
and really want log events to be continually written out to disk. You might
also use it if you want a long-term record of operationally-significant
events, or a record that will survive application crashes which don&#8217;t get
handled by the existing Incident-recording mechanism.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">foolscap.logging</span> <span class="kn">import</span> <span class="n">log</span>
<span class="n">log</span><span class="o">.</span><span class="n">bridgeLogsToTwisted</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="stdlib-logging-module">
<h4>stdlib &#8216;logging&#8217; module<a class="headerlink" href="#stdlib-logging-module" title="Permalink to this headline">¶</a></h4>
<p>stdlib <tt class="docutils literal"><span class="pre">logging</span></tt> messages must be bridged in the same way. TODO:
define and implement the bridge setup</p>
</div>
<div class="section" id="preferred-logging-api">
<h4>Preferred Logging API<a class="headerlink" href="#preferred-logging-api" title="Permalink to this headline">¶</a></h4>
<p>To take advantage of the parent/child causality mechanism, you must use
Foolscap&#8217;s native API. (to be precise, you can pass in <tt class="docutils literal"><span class="pre">parent=</span></tt>
to either Twisted&#8217;s <tt class="docutils literal"><span class="pre">log.msg</span></tt> or stdlib&#8217;s``logging.log`` , but to get a handle to use as a value to``parent=`` you must use <tt class="docutils literal"><span class="pre">foolscap.log.msg</span></tt> , because
neither stdlib&#8217;s nor Twisted&#8217;s log calls provide a return value)</p>
</div>
</div>
<div class="section" id="controlling-buffer-sizes">
<h3>Controlling Buffer Sizes<a class="headerlink" href="#controlling-buffer-sizes" title="Permalink to this headline">¶</a></h3>
<p>There is a separate circular buffer (with some maximum size) for each
combination of level and facility. After each message is added, the size of
the buffer is checked and enough old messages are discarded to bring the size
back down to the limit. Each facility uses a separate set of buffers, so that
e.g. the NOISY messages from the &#8220;ui&#8221; facility do not evict the NOISY
messages from the &#8220;upload&#8221; facility.</p>
<p>The sizes of these buffers can be controlled with the``log.set_buffer_size`` function, which is called with the severity
level, the facility name, and the desired buffer size (maximum number of
messages). If <tt class="docutils literal"><span class="pre">set_buffer_size</span></tt> is called without a facility name,
then it will set the default size that will be used when a log.msg call
references an as-yet-unknown facility).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">log</span><span class="o">.</span><span class="n">set_buffer_size</span><span class="p">(</span><span class="n">log</span><span class="o">.</span><span class="n">NOISY</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">set_buffer_size</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">log</span><span class="o">.</span><span class="n">NOISY</span><span class="p">,</span> <span class="n">facility</span><span class="o">=</span><span class="s">&quot;upload&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">allocate_facility_buffers</span><span class="p">(</span><span class="s">&quot;web&quot;</span><span class="p">)</span>
<span class="k">print</span> <span class="n">log</span><span class="o">.</span><span class="n">get_buffer_size</span><span class="p">(</span><span class="n">log</span><span class="o">.</span><span class="n">NOISY</span><span class="p">,</span> <span class="n">facility</span><span class="o">=</span><span class="s">&quot;upload&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="some-messages-are-not-worth-generating">
<h3>Some Messages Are Not Worth Generating<a class="headerlink" href="#some-messages-are-not-worth-generating" title="Permalink to this headline">¶</a></h3>
<p>If the message to be logged is below some threshold, it will not even be
generated. This makes it easy to leave the log line in the source code, but
not consume CPU time or memory space by actually using it. Such messages must
be enabled before use (either through the logport (TODO) or by restarting the
application with different log settings(TODO)), but at least developers will
not have to re-learn the source code to figure out where it might be useful
to add some messages. This threshold can be configured for all facilities at
the same time, or on a facility-by-facility basis.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">log</span><span class="o">.</span><span class="n">set_generation_threshold</span><span class="p">(</span><span class="n">log</span><span class="o">.</span><span class="n">NOISY</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">set_generation_threshold</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">log</span><span class="o">.</span><span class="n">OPERATIONAL</span><span class="p">,</span> <span class="n">facility</span><span class="o">=</span><span class="s">&quot;web&quot;</span><span class="p">)</span>
<span class="k">print</span> <span class="n">log</span><span class="o">.</span><span class="n">get_generation_threshold</span><span class="p">()</span>
<span class="k">print</span> <span class="n">log</span><span class="o">.</span><span class="n">get_generation_threshold</span><span class="p">(</span><span class="n">facility</span><span class="o">=</span><span class="s">&quot;web&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="viewing-log-messages">
<h2>Viewing Log Messages<a class="headerlink" href="#viewing-log-messages" title="Permalink to this headline">¶</a></h2>
<p>There are a variety of ways for humans (and their tools) to read and
analyze log messages. The <tt class="docutils literal"><span class="pre">flogtool</span></tt> program, provided with
Foolscap, provides access to many of them.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">flogtool</span> <span class="pre">dump</span></tt> : look at the saved log events (in a logdir)
and display their contents to stdout. Options are provided to specify the
log source, the facilities and severity levels to display, and grep-like
filters on the messages to emit.</li>
<li><tt class="docutils literal"><span class="pre">flogtool</span> <span class="pre">tail</span></tt> : connect to a logport and display new log
events to stdout. The <tt class="docutils literal"><span class="pre">--catchup</span></tt> option will also display old
events.</li>
<li><tt class="docutils literal"><span class="pre">flogtool</span> <span class="pre">gtk-viewer</span></tt> : a Gtk-based graphical tool to examine
log messages.</li>
<li><tt class="docutils literal"><span class="pre">flogtool</span> <span class="pre">web-viewer</span></tt> : runs a local web server, through
which log events can be examined.</li>
</ul>
<p>This tool uses a log-viewing API defined in``foolscap/logging/interfaces.py`` . (TODO) Application code can use
the same API to get access to log messages from inside a python program.</p>
<div class="section" id="log-views">
<h3>Log Views<a class="headerlink" href="#log-views" title="Permalink to this headline">¶</a></h3>
<p>(NOTE: this section is incomplete and has not been implemented)</p>
<p>Many of these tools share the concept of &#8220;Log Views&#8221;. This is a particular
set of filters which can be applied to the overall log event stream. For
example, one view might show all events that are UNUSUAL or worse. Another
view might show NOISY messages for the &#8220;ui&#8221; facility but nothing else.</p>
<p>Each view is described by a set of thresholds: each facility gets a
severity threshold, and all messages at or above the threshold will be
included in the view. While in principle there is a threshold for each
facility, this may be expressed as a single generic threshold combined with
overrides for a few specific facilities.</p>
</div>
<div class="section" id="log-observers">
<h3>Log Observers<a class="headerlink" href="#log-observers" title="Permalink to this headline">¶</a></h3>
<p>A &#8220;Log Observer&#8221; can be attached to a foolscap-using program (either
internally or by subscribing through the flogport). Once attached, this
observer will receive a stream of log messages, which the observer is then
free to format, store, or ignore as it sees fit.</p>
<p>Each log message is a dictionary, as defined in <a class="reference internal" href="specifications/logfiles.html"><em>specifications/logfiles</em></a> .</p>
<div class="highlight-python"><pre>def observe(event):
    print strftime(fmt, event.timestamp)
    print event["level"] # a number
    print event.get("facility" # a string like "ui"
    print event["message"]  # a unicode object with the actual event text

log.theLogger.addObserver(observe)</pre>
</div>
</div>
<div class="section" id="running-a-log-gatherer">
<h3>Running a Log Gatherer<a class="headerlink" href="#running-a-log-gatherer" title="Permalink to this headline">¶</a></h3>
<p>A &#8220;Log Gatherer&#8221; is a python server to which the process under examination
sends some or all of its log messages. These messages are saved to a file as
they arrive, so they can be examined later. The resulting logfiles can be
compressed, and they can be automatically rotated (saved, rename, reopened)
on a periodic interval. In addition, sending a SIGHUP to the gatherer will
cause it to rotate the logfiles.</p>
<p>To create one, choose a new directory for it to live in, and run
&#8220;<tt class="docutils literal"><span class="pre">flogtool</span> <span class="pre">create-gatherer</span></tt> &#8221;. You can then start it with &#8220;twistd&#8221;,
and stop it by using the <tt class="docutils literal"><span class="pre">twistd.pid</span></tt> file:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">%</span> flogtool create-gatherer lg
<span class="go">Gatherer created in directory lg</span>
<span class="go">Now run &#39;(cd lg &amp;&amp; twistd -y gatherer.tac)&#39; to launch the daemon</span>
<span class="gp">%</span> <span class="nb">cd </span>lg
<span class="gp">%</span> ls
<span class="go">gatherer.tac</span>
<span class="gp">%</span> twistd -y gatherer.tac
<span class="gp">%</span> ls
<span class="go">from-2008-07-28--13-30-34Z--to-present.flog  log_gatherer.furl  twistd.pid</span>
<span class="go">gatherer.pem                                 portnum</span>
<span class="go">gatherer.tac                                 twistd.log</span>
<span class="gp">%</span> cat log_gatherer.furl
<span class="go">pb://g7yntwfu24w2hhb54oniqowfgizpk73d@192.168.69.172:54611,127.0.0.1:54611/z4ntcdg4jpdg3pnabhmyu3qvi3a7mdp3</span>
<span class="gp">%</span> <span class="nb">kill</span> <span class="sb">`</span>cat twistd.pid<span class="sb">`</span>
<span class="gp">%</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">log_gatherer.furl</span></tt> string is the one that should be
provided to all applications whose logs should be gathered here. By using``tub.setOption(&#8220;log-gatherer-furlfile&#8221;, &#8220;log_gatherer.furl&#8221;)`` in
the application, you can just copy this .furl file into the application&#8217;s
working directory.</p>
</div>
<div class="section" id="running-an-incident-gatherer">
<h3>Running an Incident Gatherer<a class="headerlink" href="#running-an-incident-gatherer" title="Permalink to this headline">¶</a></h3>
<p>An &#8220;Incident Gatherer&#8221; is like a Log Gatherer, but it only gathers
weirdness-triggered Incidents. It records these incidents into files on the
local disk, and provides access to them through a web server. The Incident
Gatherer can also be configured to classify the incidents into various
categories (perhaps expressions of a specific bug), to facilitate analysis by
separating known problems from new ones.</p>
<p>To create one, choose a new directory for it to live in, and run
&#8220;<tt class="docutils literal"><span class="pre">flogtool</span> <span class="pre">create-incident-gatherer</span></tt> &#8221;, just like the log
gatherer:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">%</span> flogtool create-incident-gatherer ig
<span class="go">Gatherer created in directory ig</span>
<span class="go">Now run &#39;(cd ig &amp;&amp; twistd -y gatherer.tac)&#39; to launch the daemon</span>
<span class="gp">%</span> <span class="nb">cd </span>ig
<span class="gp">%</span> ls
<span class="go">gatherer.tac</span>
<span class="gp">%</span> twistd -y gatherer.tac
<span class="gp">%</span>
</pre></div>
</div>
<div class="section" id="incident-storage">
<h4>Incident Storage<a class="headerlink" href="#incident-storage" title="Permalink to this headline">¶</a></h4>
<p>Inside the gatherer&#8217;s base directory (which we refer to as BASEDIR here),
the <tt class="docutils literal"><span class="pre">incidents/</span></tt> directory will contain a subdirectory for each
tub that connects to the gatherer. Each subdir will contain the incident
files, named <tt class="docutils literal"><span class="pre">incident-TIMESTAMP-UNIQUE.flog.bz2</span></tt> .</p>
<p>A simple unix command like <tt class="docutils literal"><span class="pre">find</span> <span class="pre">BASEDIR/incidents</span> <span class="pre">-name</span> <span class="pre">'incident-*.flog.bz2'</span></tt> will locate all incident files. Each incident
file can be examined with a tool like <tt class="docutils literal"><span class="pre">flogtool</span> <span class="pre">dump</span></tt> . The format
is described in the <a class="reference internal" href="specifications/logfiles.html"><em>Logfiles specification</em></a> docs.</p>
</div>
<div class="section" id="classification">
<h4>Classification<a class="headerlink" href="#classification" title="Permalink to this headline">¶</a></h4>
<p>The Incident Gatherer uses a collection of user-supplied classification
functions to analyze each Incident and place it into one or more categories.
To add a classification function, create a file with a name like
&#8220;<tt class="docutils literal"><span class="pre">classify_*.py</span></tt> &#8221; (such as <tt class="docutils literal"><span class="pre">classify_foolscap.py</span></tt> or``classify_db.py`` ), and define a function in it named
&#8220;<tt class="docutils literal"><span class="pre">classify_incident()</span></tt> &#8221;. Place this file in the gatherer&#8217;s
directory. All such files will be loaded and evaluated when the gatherer
starts.</p>
<p>The <tt class="docutils literal"><span class="pre">classify_incident()</span></tt> function will accept a single
triggering event (a regular log Event dictionary, see logfiles.xhtml for
details, which can be examined as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">classify_incident</span><span class="p">(</span><span class="n">trigger</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">trigger</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;message&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s">&quot;Tub.connectorFinished:&quot;</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&#39;foolscap-tubconnector&#39;</span>
</pre></div>
</div>
<p>The function should return a list (or set) of categories, or a single
category string, or None. Each incident can wind up in multiple categories.
If no function finds a category for the incident, it will be added to the
&#8220;unknown&#8221; category. All incidents are added to the &#8220;all&#8221; category.</p>
<p>The <tt class="docutils literal"><span class="pre">classified/</span></tt> directory will contain a file for each
defined classification. This file will contain one line for each incident
that falls into that category, containing the BASEDIR-relative pathname of
the incident file (i.e. each line will look like``incidents/TUBID/incident-TIMESTAMP-UNIQUE.flog.bz2`` ). The``classified/all`` file will contain the same filenames as the``find`` command described earlier.</p>
<p>If the <tt class="docutils literal"><span class="pre">classified/</span></tt> directory does not exist when the gatherer
is started, all stored Incidents will be re-classified. After modifying or
adding classification functions, you should delete the``classified/`` directory and restart the gatherer.</p>
</div>
<div class="section" id="incident-gatherer-web-server">
<h4>Incident Gatherer Web Server<a class="headerlink" href="#incident-gatherer-web-server" title="Permalink to this headline">¶</a></h4>
<p>The Incident Gatherer can run a small webserver, to publish information
about the incidents it collects. The plan is to have it publish an RSS feed
of incidents by category, and to serve incidents as HTML just like the``foolscap web-viewer`` command. This code is not yet written.</p>
</div>
<div class="section" id="incident-reports-by-email">
<h4>Incident Reports by Email<a class="headerlink" href="#incident-reports-by-email" title="Permalink to this headline">¶</a></h4>
<p>The Incident Gatherer can also be configured to send email with a
description of the incident for various categories. The incident report will
be included as an attachment for further analysis. This code is not yet
written.</p>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Foolscap Logging</a><ul>
<li><a class="reference internal" href="#philosophy">Philosophy</a><ul>
<li><a class="reference internal" href="#memory-limited-strangeness-triggered-log-dumping">Memory-limited, strangeness-triggered log dumping</a></li>
<li><a class="reference internal" href="#structured-logging">Structured Logging</a></li>
<li><a class="reference internal" href="#remote-log-aggregation">Remote log aggregation</a></li>
<li><a class="reference internal" href="#causality-tracing">Causality Tracing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-foolscap-logging">Using Foolscap Logging</a><ul>
<li><a class="reference internal" href="#logging-messages-from-application-code">Logging Messages From Application Code</a><ul>
<li><a class="reference internal" href="#modifying-log-messages">Modifying Log Messages</a></li>
<li><a class="reference internal" href="#logging-messages-through-a-tub">Logging Messages Through a Tub</a></li>
</ul>
</li>
<li><a class="reference internal" href="#facilities">Facilities</a></li>
<li><a class="reference internal" href="#that-was-weird-buttons">&#8220;That Was Weird&#8221; Buttons</a></li>
</ul>
</li>
<li><a class="reference internal" href="#configuring-logging">Configuring Logging</a><ul>
<li><a class="reference internal" href="#saving-log-events-to-disk">Saving Log Events to Disk</a><ul>
<li><a class="reference internal" href="#incidents">Incidents</a></li>
</ul>
</li>
<li><a class="reference internal" href="#setting-up-the-logport">Setting up the logport</a></li>
<li><a class="reference internal" href="#configuring-a-log-gatherer">Configuring a Log Gatherer</a></li>
<li><a class="reference internal" href="#interacting-with-other-logging-systems">Interacting With Other Logging Systems</a><ul>
<li><a class="reference internal" href="#twisted-python-log">twisted.python.log</a></li>
<li><a class="reference internal" href="#stdlib-logging-module">stdlib &#8216;logging&#8217; module</a></li>
<li><a class="reference internal" href="#preferred-logging-api">Preferred Logging API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#controlling-buffer-sizes">Controlling Buffer Sizes</a></li>
<li><a class="reference internal" href="#some-messages-are-not-worth-generating">Some Messages Are Not Worth Generating</a></li>
</ul>
</li>
<li><a class="reference internal" href="#viewing-log-messages">Viewing Log Messages</a><ul>
<li><a class="reference internal" href="#log-views">Log Views</a></li>
<li><a class="reference internal" href="#log-observers">Log Observers</a></li>
<li><a class="reference internal" href="#running-a-log-gatherer">Running a Log Gatherer</a></li>
<li><a class="reference internal" href="#running-an-incident-gatherer">Running an Incident Gatherer</a><ul>
<li><a class="reference internal" href="#incident-storage">Incident Storage</a></li>
<li><a class="reference internal" href="#classification">Classification</a></li>
<li><a class="reference internal" href="#incident-gatherer-web-server">Incident Gatherer Web Server</a></li>
<li><a class="reference internal" href="#incident-reports-by-email">Incident Reports by Email</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="flappserver.html"
                        title="previous chapter">Flappserver: The Foolscap Application Server</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="schema.html"
                        title="next chapter">Foolscap Schemas</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/logging.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="schema.html" title="Foolscap Schemas"
             >next</a> |</li>
        <li class="right" >
          <a href="flappserver.html" title="Flappserver: The Foolscap Application Server"
             >previous</a> |</li>
        <li><a href="index.html">Foolscap v0.6.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Brian Warner.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>